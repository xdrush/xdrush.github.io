<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Attention机制及其在计算广告中的应用]]></title>
      <url>https://xdrush.github.io/2017/10/23/Attention%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%9C%A8%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="text"><![CDATA[背景说明在搜索广告和信息流广告中，除了常说的各种模型的应用之外，还有一块往往被大家所忽视，那就是物料优化，但是广告物料是直接呈现在网民面前的，对这一部分做好了优化工作无疑对广告的点击率/cpm以及用户体验上大有裨益。 物料优化中最重要的两点就是：（1）&lt;关键词，标题&gt;的相关性以及标题质量；（2）&lt;关键词，图&gt;的相关性以及图片质量。当广告库规模较小时，通过运营手段能取得较好的效果，但是当关键词达到几十万甚至几百万乃至千万量级时，人力手段就显得力不从心了。 这时，深度学习就能发挥优势。AI领域的两大难题就是：（1）自然语言理解；（2）图片理解；广告物料优化又恰恰是这两个领域的结合，因此想借助于深度学习等技术手段完全解决物料优化的问题是显然不可能的，只能Word2Vec、CNN、LSTM、Attention等技术手段进行初步优化；Attention机制恰恰能在较好的应用在这一场景中。 Attention机制原理最近两年，注意力模型（Attention Model）被广泛应用于NLP，图像识别等领域中，甚至有基于Attention的FM模型AFM，下面将以机器翻译为例，简单阐述Attention模型的基本原理。 Attention机制起源Attention模型源自于人类的注意力机制，上图描述的人类的视觉注意力在观察某个对象时，视觉的重点分布。颜色越深表示关注这一部分的注意力越强。我们发现，在观看小孩这个图片时，将视觉重心放在面部，在看一篇文章时，注意力重点分布在文章标题，摘要头部和文章头部位置，这也比较符合我们观察事物是视觉重心的分布。 深度学习中的注意力机制从本质上来说同人类的视觉注意力机制类似，核心都是从众多的信息中选择出对当前任务目标更关键的信息。 Encoder-Decoder框架目前基本上所有的Attention模型都是建立在Encoder-Decoder框架之上的，所以有必要先了解下Encoder-Decoder框架。 上图就是一个最基本的框架示意图。以NLP领域中的Encoder-Decoder框架来更直观的理解这个框架：可以把它看做处理由一个句子（或一篇文章）生成另外一个句子（文章）的通用模型（也就是机器翻译）。对于句子对，我们的目标是给定输入句子Source，期待通过Encoder-Decoder框架来生成目标句子Target。Source和Target可以是同一种语言，也可以是两种不同的语言。而Source和Target分别由各自的单词序列组成： Encoder顾名思义就是对输入句子Source进行编码，将输入句子通过非线性变换转化为中间语义表示C： 对于解码器Decoder来说，其任务就是根据句子Source的中间语义表示C和之前已经生成的历史信息y(1),y(2),y(i-1)来生成i时刻的单词y(i)： 每个y(i)都依次这么产生，那么看起来就是整个系统根据输入句子Source生成了目标句子Target。如果Source是中文句子，Target是英文句子，那么这就是解决机器翻译问题的Encoder-Decoder框架；如果Source是一篇文章，Target是概括性的几句描述语句，那么这是文本摘要的Encoder-Decoder框架；如果Source是一句问句，Target是一句回答，那么这是问答系统或者对话机器人的Encoder-Decoder框架。由此可见，在文本处理领域，Encoder-Decoder的应用领域相当广泛。 Encoder-Decoder框架不仅仅在文本领域广泛使用，在语音识别、图像处理等领域也经常使用。比如对于语音识别来说，上图所示的框架完全适用，区别无非是Encoder部分的输入是语音流，输出是对应的文本信息；而对于“图像描述”任务来说，Encoder部分的输入是一副图片，Decoder的输出是能够描述图片语义内容的一句描述语。一般而言，文本处理和语音识别的Encoder部分通常采用RNN模型，图像处理的Encoder一般采用CNN模型。 Attention模型本节以机器翻译作为例子来讲解最基本的Attention模型的原理。 上节的Encoder-Decoder没有体现出“注意力模型”，可以把它看作是注意力不集中的分心模型。为什么这么说呢？请看下面目标句子Target中每个单词的生成过程： 其中f是Decoder的非线性变换函数。从这里不难看出，在生成目标句子的单词时，不论是生成那个单词，他们使用的输入句子Source的语义编码C都是一样的，没有任何区别。 而语义编码C是由句子Source的每个单词经过Encoder 编码产生的，这意味着不论是生成哪个单词，y(1)、y(2)还是y(3)，其实句子Source中任意单词对生成某个目标单词y(i)来说影响力都是相同的，这是为何说这个模型没有体现出注意力的缘由。这类似于人类看到眼前的画面，但是眼中却没有注意焦点一样。 如果拿机器翻译来解释这个分心模型的Encoder-Decoder框架更好理解，比如输入的是英文句子：Tom chase Jerry，Encoder-Decoder框架逐步生成中文单词：“汤姆”，“追逐”，“杰瑞”。在翻译“杰瑞”这个中文单词的时候，分心模型里面的每个英文单词对于翻译目标单词“杰瑞”贡献是相同的，很明显这里不太合理，显然“Jerry”对于翻译成“杰瑞”更重要，但是分心模型是无法体现这一点的，这就是为何说它没有引入注意力的原因。 没有引入注意力的模型在输入句子比较短的时候问题不大，但是如果输入句子比较长，此时所有语义完全通过一个中间语义向量来表示，单词自身的信息已经消失，可想而知会丢失很多细节信息，这也是为何要引入注意力模型的重要原因。 上面的例子中，如果引入Attention模型的话，应该在翻译“杰瑞”的时候，体现出英文单词对于翻译当前中文单词不同的影响程度，比如给出类似下面一个概率分布值：1(Tom, 0.3) (Chase, 0.2) (Jerry, 0.5) 每个英文单词的概率代表了翻译当前单词“杰瑞”时，注意力分配模型分配给不同英文单词的注意力大小。这对于正确翻译目标语单词肯定是有帮助的，因为引入了新的信息。 同理，目标句子中的每个单词都应该学会其对应的源语句子中单词的注意力分配概率信息。这意味着在生成每个单词y(i)的时候，原先都是相同的中间语义表示C会被替换成根据当前生成单词而不断变化的C(i)。理解Attention模型的关键就是这里，即由固定的中间语义表示C换成了根据当前输出单词来调整成加入注意力模型的变化的C(i)。增加了注意力模型的Encoder-Decoder框架理解起来如下图所示： 因此，目标句子单词的生成过程变成了下面的形式： 而每个C(i)可能对应着不同的源句子单词的注意力分布概率，比如： 其中，f2函数代表Encoder对输入英文单词的某种变换函数，比如如果Encoder是用的RNN模型的话，这个f2函数的结果往往是某个时刻输入x(i)后隐层节点的状态值；g代表Encoder根据单词的中间表示合成整个句子中间语义表示的变换函数，一般的做法中，g函数就是对构成元素加权求和，即下列公式： 其中，L(x)代表输入句子Source的长度，a(ij)代表代表在Target输出第i个单词时Source输入句子中第j个单词的注意力分配系数，而h(j)则是Source输入句子中第j个单词的语义编码。假设C(i)下标i就是上面例子所说的“ 汤姆” ，那么L(x)就是3，h1=f(“Tom”)，h2=f(“Chase”),h3=f(“Jerry”)分别是输入句子每个单词的语义编码，对应的注意力模型权值则分别是0.6,0.2,0.2，所以g函数本质上就是个加权求和函数。如果形象表示的话，翻译中文单词“汤姆”的时候，数学公式对应的中间语义表示的形成过程类似下图： 这里还有一个问题：生成目标句子某个单词，比如“汤姆”的时候，如何知道Attention模型所需要的输入句子单词注意力分配概率分布值呢？就是说“汤姆”对应的输入句子Source中各个单词的概率分布：(Tom,0.6)(Chase,0.2) (Jerry,0.2) 是如何得到的呢？为了便于说明，我们假设对上图的非Attention模型的Encoder-Decoder框架进行细化，Encoder采用RNN模型，Decoder也采用RNN模型，这是比较常见的一种模型配置，则上图的框架转换为下图： 那么用上图可以较为便捷地说明注意力分配概率分布值的通用计算过程： 对于采用RNN的Decoder来说，在时刻i，如果要生成y(i)单词，我们是可以知道Target在生成之前的时刻i-1时，隐层节点i-1时刻的输出值H(i-1)的，而我们的目的是要计算生成y(i)时输入句子中的单词“Tom”、“Chase”、“Jerry”对y(i)来说的注意力分配概率分布，那么可以用Target输出句子i-1时刻的隐层节点状态H(i-1)去一一和输入句子Source中每个单词对应的RNN隐层节点状态h(j)进行对比，即通过函数F(h(j),H(i-1))来获得目标单词y(i)和每个输入单词对应的对齐可能性，这个F函数在不同论文里可能会采取不同的方法，然后函数F的输出经过Softmax进行归一化就得到了符合概率分布取值区间的注意力分配概率分布数值。 绝大多数Attention模型都是采取上述的计算框架来计算注意力分配概率分布信息，区别只是在F的定义上可能有所不同。 以上便是Attention模型的基本思想；接下来分享两篇Attention模型在计算广告中的应用。 Attention模型应用于文本分类文本分类在计算广告中有诸多应用场景，最典型的比如关键词-行业分类，创意标题-行业分类等，分类准确率的提升对广告点击率、cpm等指标能起到很直接的作用。 传统的文本分类方式比如贝叶斯分类、线性分类器系列、SVM系列以及近两年提出的CNN系列，能达到很好的性能，但是以上算法的一个劣势就是分类是基于已经训练好的静态的word2vector，没有考虑到具体的权重信息，而Attention机制正好可以弥补这个劣势。这里给大家分享一篇基于Attention机制的文本分类算法HAN-Hierarchical Attention Networks for Document Classification，本文的创新点个人认为有两个： 提出了一种层次网络； 将Attention模型应用于每层网络中； 下面来剖析文章主要思想； 模型结构文章提出的HAN结构如下图所示： 由模型结构图可知，Hierarchical主要体现在两个店方： 由word生成句子向量； 由sentence生成document向量； 在上两个过程中，融入了Attention机制。Encoder采用的是GRU（一种类似于LSTM的网络，比LSTM少一个门），具体生成sentence vector和document vector的过程如下： 上式中，w(it)表示第i个sentence的第t个word，W(e)为一个静态矩阵，可理解为就是一个word2vector，最终的隐层结果就是h(it)为双向GRU的结果拼接在一起。得到中间隐层表示之后，就将隐层结果作为attention的输入： 其中u(w)随机初始化并参与到学习过程中，最终，s(i)就是经过Attention模型生成的Sentence vector。类似的，有了sentence vector之后，经过同样的Attention模型，得到document的vector表示如下：最终v就是整个document的向量表示。 Softmax分类及Loss得到document的向量表示之后，即可用softmax对向量进行分类了： 优化目标为：p(dj)表示文档d属于j的概率。 性能比较最终HAN的性能如下图所示：从作者的实验结果看出，HAN相较于传统的文本分类算法，性能有显著的提升。 Attention模型应用于看图说话在信息流广告和搜索广告中，广告图片对于广告投放效果起着举足轻重的作用，我们在信息流广告中，对top100 pv的关键词图片进行优化，导致CTR直接提升7%，cpm提升5%左右的效果，这是各种模型所远远不能达到的效果。在百度凤巢系统中，百度广告创意部会推荐若干个标题给推广账户，但是图却是收费的，可见广告图片对于广告的地位是多么重要！ 在我们的广告系统中，关键词配图、账户配图对于图片的要求相当苛刻，要在众多的图片候选集中选择最合适的图片一直是一个难点。Attention的应用能够极大的提升图文相关性。下面结合《Show, Attend and Tell: Neural Image Caption Generation with Visual Attention》一文详细介绍Attention在看图说话中的应用。 模型简介模型的结构如下图：模型把图片经过CNN网络，变成特征图，LSTM在此上运行Attention模型，最后得到最终的描述。 Encoder实现将经过CNN之后得到的图片特征图切割成多个区域，表示为：L表示切割的区域个数，paper中区域的大小为14*14，D=196。输出的描述y可以编码为：K表示词汇词典的大小，C为描述的长度，y(i)为one-hot表示。 Decoder实现该模型的LSTM结构如下图所示：上图就是典型的LSTM的几个门结构，运算方式为： 上式中z(t)表示对整张图片部分信息的动态表示，是一个Attention模型，计算方式如下： 其中i表示第i个特征区域，共有L个；函数f(att)采用的是一个MLP，利用前一时刻的隐层状态h(t-1)与L个特征区域，分别得到每个区域的权重a(ti)，权重a(ti)可以理解为(1)下一步选择哪一个区域的概率，也可以理解为(2)每一个区域在下一次输入中所占的比例；不同的理解与应用，体现在函数z(t)的不同实现上。 按(1)的实现称为Stochastic “Hard” Attention，按(2)的实现称为Deterministic “Soft” Attention。下图实例很好的表现了Hard和Soft这两种方式的区别： 可以看出，Soft在选择图像区域时更加平滑。 LSTM中的记忆单元和隐藏单元的初始值，是两个不同的多层感知机，采用所有特征区域的平均值来进行初始化的。而最终的单词概率输出，采用深度输出层实现： Stochastic “Hard” Attentions(t, i)表示是否选择L个特征图中的第i个，如果设置为1，表示选中，0表示不选中。在随机“Hard”模型中，每次只选中一个区域。则z(t)的计算方式如下： 我们设置logp(y|a)函数的下限为优化的目标函数L(s)： 对其进行参数求导有： 以上参数求导可用蒙特卡洛方法采样实现： 为减少估计方差，可采用冲量方式，第k个mini-batch的时候： 为进一步减少估计方差，引入多项式分布的熵H(s)： 以上参数求导优化的过程就是强化学习，每次选择下一个特征图的过程都朝着目标更好的方向变化。值得注意的是，Hard Attention在优化目标时，采用随机梯度上升方式。 Deterministic “Soft” Attention上面的”Hard”随机模型需要随机采样位置s(t)，我们还可以直接计算z(t)：这就是Deterministic “Soft” Attention模型，通过a(t,i)来选择感兴趣的特征区域，每个特征区域都有一个权重。在计算具体的a(t,i)时，有： 也就是，通过上面这个限制条件保证每个区域的权重之和等于1。另外，加入一个新的正则，对每一个区域，在所有的T步中，将被观察到的权重之和拉近：这个正则的加入，可以使得生成的描述更加丰富，结果会更好。另外，在z(t)的计算中添加一个标量进行缩放，通过前一个隐藏单元h(t-1)来计算： 最终的目标函数为： 与Hard不同的是，Soft采用的是随机梯度下降方式更新超参数。 Attention在物料优化中的应用目前结合我们组的业务场景，主要是将Attention模型应用于生成图片描述，然后根据相关性，计算关键词和描述之间的相关性，进而为关键此配图。 如上图，在广告图库中随机抽取一张美容相关的照片，预测结果中“胶原蛋白”真是我们想要的关键词。（在构造样本时，将关键词+标题拼接在一起当做图片描述，主要是考虑到现在很多广告采用了标题党这种新式） 上图是一个badcase，给出的图片应该是金融理财类的，生成的描述却是糖尿病相关的。目前，因为标注的数据集较少，模型尚达不到要求，后续随着数据的增多，相信这种方式可以较好的服务于计算广告。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DSSM/CLSM原理及其在计算广告中的应用]]></title>
      <url>https://xdrush.github.io/2017/09/17/DSSM:CLSM%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%9C%A8%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="text"><![CDATA[背景说明在搜索广告或者信息流中融入搜索广告时，通常我们需要对关键词进行行业标注，目的是为了方便在某些特殊渠道或者特定场景下对某些行业进行屏蔽。比如，在信息流广告中，通常是看不到医疗类广告的身影，这是因为在大部分信息流广告中，为了用户体验，而选择性的将医疗类广告做了屏蔽；然而，医疗类广告在搜索广告收入中的占比依然很大；另一种场景是，在某个特定的时间，应某些方面的强制需求，不允许出现某行业相关的广告，比如在19大期间，应上面要求，信息流中不允许出现棋类赌博类广告，大家都知道棋牌类广告的CPC通常都很高，消耗占比通常也很高； 因此，要做到实时响应各方需求，最好的做法是对广告主购买的关键词进行行业标注；标注示例如下：| 关键词 | 行业 || ——- | ——: || 专升本有哪些学校 | 教育/其他 || 注册会计师报名条件 | 教育/从业资格 || 美国留学咨询 | 教育/出国留学 | 上表中，行业那一列一般根据业务需要可分为一级行业和二级行业，上例中，教育为一级行业，其他、从业资格和出国留学，是二级行业，具体分为几级行业，视具体业务场景而定。 那么，如何对大规模关键词进行行业标注呢？人工标注显然不现实（通常数据规模几万到几十万不等），文本分类模型的引入是必然的。现阶段，我们的文本分类模型是基于分层贝叶斯思想，用的是15年左右根据当前的业务场景训练出来的，模型有两年多没有更新了，随着新的关键词的而引入，分类准确率必定会越来越低。事实证明，15年左右模型的分类准确率在95%左右，目前只有80%左右。 后面我将会讲解一系列文本分类方法，结合具体的应用场景来解决这个问题。 DSSMDSSM来自于这篇文章(Learning Deep Structured Semantic Models for Web Search using Clickthrough Data)，13年由Microsoft的Xiaodong He提出（后面这个团队还提出了Sentence2Vector模型），据目前所知，DSSM目前在Baidu和Alibaba的NLP业务中，都有其应用地方。这里就剖析下DSSM的原理及思想。 DSSM提出背景DSSM最开始提出的应用场景是搜索排序中，当用户输入一个关键词query是，如何按序展示搜索结果？DSSM提出的正是为了解决这个问题。将某个query被点击的document当做正样本，展示了却未被点击的document当做负样本，通过这些训练数据，来预测某个query被点击的可能性。 DSSM模型结构DSSM模型的整体结构如下图：上图中，Q表示查询词query，D(i)表示搜索结构对应的document，一个query对应多个document，D(i)(i = 1, 2, …, n)中有一个被点击的正样本，其他的都是负样本。 基本思想是将query和每个document都经过相同的网络结构，然后计算query和每个document的relevance，这里的relevance采用余弦距离计算方法，得到query和每个document的relevance之后，再经过带系数的softmax，从而得到query和每个document的相关score，最终document依据score进行排序； 网络结构query和每个document都经过相同的网络结构，DNN每一层的处理如下式：其中f(x)采用的是tanh激活函数。 相关性计算query和每个document经过网络得到128维的输出结构之后，计算query和每个document的余弦距离：y(Q)和y(D)分别表示query和每个document经过DNN之后的输出。 结果预测得到余弦距离还不是最终的结果，最终得要转化为每个document的得分，很容易想到softmax，本文也正是这么做的，不过在计算softmax值时引入了平滑因子：上式中r即为引入的平滑因子，r是经验值，视具体应用场景而定，不是超参数。 损失函数训练时，DSSM通过最大化正样本的被点击的概率来实现学习过程，参数更新采用SGD算法。 超参数初始化方式本文中超参数的初始化方式比较经典，值得借用：DNN的超参数初始化为上面值范围内的均匀分布，不太记得是哪篇paper中有详细论述这种初始化方式能较快的收敛。 其他实现细节在构造训练数据时，为实现数据对齐，每个query只有1个被点击的document作为正样本，4个未被点击的document作为负样本。 Word HashingWord Hashing是本文提出的一个关键方法：该方法通过将每一个word处理成letter-n gram维度的表示来实现降维的目的。其核心思想如下： 考虑单个word，以good为例，如果采用one-hot表示，那么每个word的维度将会非常大，假设训练样本有500k个独立的单词，那么每个word的one-hot也会是500k维，计算复杂度比较高。本文提出基于letter-n gram维度的词表示，首先为每个word加上开始和结束标志（good表示为#good#），以letter-3为例，将#good#进一步表示为#go，goo，ood，od#，最终将word用letter-n的vector来表示；具体的实现方式在下一篇文章中可以获知：以上图为例，#bo，boy，oy#是one-hot表示，但是整个boy的vector是这三个的和，因此boy是multi-hot表示。每个query和document由多个word组成，其对应的vector也是若干个word的和表示。 作者表示，英文单词的个数可以是无限多个，但是letter-n的总个数却是比较固定的，并且个数比较少；据作者统计，500k个词汇，最终可以用30k个letter-n来表示，并且冲突率只有0.0044%（22/500k）。 存在的问题通过上面的分析，我们不难发现，DSSM通过求和的方式显然丢失了word与word之间的上下文信息。紧接着，下文就产生了！ CLSM讲完了DSSM，就不得不提CLSM（A Latent Semantic Model with Convolutional-Pooling Structure for Information Retrieval），源自于同一个团队，要解决的问题也是相同的，CLSM不同于DSSM的地方主要在于以下两个方面： 引入了CNN； 考虑了context上下文信息；那么CLSM是如何做的呢？ CLSM模型结构CLSM模型采用的结构如下： word-n gram从上图可知，clsm首先对输入通过一个滑动窗口的形式取n个连续的word（本例中n=3），正是这种word-n gram，考虑了每个word前后的信息，因此就保留了上下文信息。 letter-n gram针对每个word，采用了同DSSM中类似的处理方法：采用letter-n gram来获取每个word的vector，再将一个窗口内的n个word拼接成n*30k的向量表示，拼接也保留了上下文信息； 卷积层从letter-trigram到convolutional layer，用CNN实现，将维度从90k降到300，抽取更高维和更抽象的表示； Max-Pooling经过卷积层后，通常情况下，由于输入的query或者document长度不一致，因此卷积层的长度肯定也各不相同，Max-Pooling抽取300维对应下标的最大值，最终组成一个300维的向量，然后再经过一个神经网络得到最终的128维向量表达。以上的激活函数都是tanh。 结果预测CLSM的结果预测同DSSM一样， 损失函数损失函数也跟DSSM一样： 以上便是对DSSM和CLSM的理解，DSSM/CLSM提出的初衷是解决搜索中的文档排序问题，但是也可以延伸到计算广告中。 DSSM/CLSM在计算广告中的应用据同事了解，DSSM/CLSM已经广告应用在百度和阿里的广告业务场景中，在我们的应用场景中，主要有以下几个方面可以借鉴： 搜索广告关键词相关性在搜索广告中，通常一个关键词被多个广告主购买，因此每个关键词就会对应多组创意，怎样根据关键词召回最合理的广告？DSSM/CLSM提供了一种思路：根据每个关键的历史click和pv，结合context和ad，对每个创意进行打分，可以实现类似于CTR预估的功能。 文本分类问题正如本文最开始所提出的问题，在对关键词进行行业分类时，每个关键词对应于一个正确的分类，可以随机挑选多个不正确的分类当做训练数据，当然这只是一种思路，行不行得要试验才知道。 广告创意优化在信息流广告或者搜索广告中，每个关键词一般有多个标题，那么如何在这么多标题候选集中选择相关的标题呢？用传统的word2vector当然能够实现一个baseline，我们组之前一直都是这么做的，但是在PM审核关键词标题相关性时，一般过审率不高。在用关键词配标题的业务场景中，基于已有的关键词-标题对可以很好将CLSM利用起来。这也不失为一种物料优化的思路。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仿斗鱼Android客户端结构实现]]></title>
      <url>https://xdrush.github.io/2017/01/31/%E4%BB%BF%E6%96%97%E9%B1%BCAndroid%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="text"><![CDATA[1. 实现说明本文旨在通过TabLayout和ViewPager打造最常见的底部导航栏+多Tab结构的Android App。 1.1 斗鱼Android客户端结构先来简要看看斗鱼客户端基本结构： 首页结构 直播页结构 1.2 模仿结构示意图模仿首页 模仿直播页 其中，首页和直播页最大的区别是首页只有5个tab，儿直播页则有10个tab，其中几个tab又有若干个子Tab。 2. 代码实现2.1 主体代码实现采用Android官方提供的TabLayout+ViewPager结构来实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 点击每个底部导航栏中的子项所对应的基类Fragment. * * Created by xdrush on 2017/1/26. */public abstract class BaseItemFragment extends Fragment &#123; TabLayout mTabLayout; ViewPager mViewPager; ItemFragmentAdapter mFragmentAdapter; List&lt;Fragment&gt; mFragmentList; List&lt;String&gt; mTitleList; @Override public View onCreateView(LayoutInflater layoutInflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = layoutInflater.inflate(R.layout.main_content_fragment_layout, container, false); setupViews(view); initFragment(); setupFragment(); return view; &#125; private final void setupViews(View view) &#123; mTabLayout = (TabLayout) view.findViewById(R.id.tablayout); mViewPager = (ViewPager) view.findViewById(R.id.viewpager); mFragmentList = new ArrayList&lt;&gt;(); mTitleList = new ArrayList&lt;&gt;(); &#125; private final void setupFragment() &#123; int size = mTitleList.size(); if (getActivity() == null || 0 == size) &#123; return; &#125; for (int i = 0; i &lt; size; i ++) &#123; mTabLayout.addTab(mTabLayout.newTab().setText(mTitleList.get(i))); &#125; // 方法一：有bug， 没有回弹.// mFragmentAdapter = new ItemFragmentAdapter(getActivity().getSupportFragmentManager(),// mFragmentList, mTitleList); // 方法二：bug fixed， 有回弹. mFragmentAdapter = new ItemFragmentAdapter(getChildFragmentManager(), mFragmentList, mTitleList); mViewPager.setAdapter(mFragmentAdapter); mTabLayout.setupWithViewPager(mViewPager); setTabLayoutMode(); &#125; public abstract void setTabLayoutMode(); public abstract void initFragment();&#125;/** * 首页Fragment. * * Created by xdrush on 2017/1/26. */public class MainPageFragment extends BaseItemFragment &#123; private static final int TAB_COUNTS = 5; private static final String[] TITLE = &#123;"推荐", "手游", "娱乐", "游戏", "趣玩", ""&#125;; @Override public void initFragment() &#123; for (int i = 0; i &lt; TAB_COUNTS; i ++) &#123; String title = TITLE[i]; mTitleList.add(title); BaseContentFragment fragment = new BaseContentFragment(); fragment.setContent(title); mFragmentList.add(fragment); &#125; mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; BaseContentFragment baseContentFragment = (BaseContentFragment) mFragmentList.get(position); baseContentFragment.setContent(mTitleList.get(position)); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); &#125; @Override public void setTabLayoutMode() &#123; mTabLayout.setTabMode(TabLayout.MODE_FIXED); &#125;&#125;/** * 直播页面对应的Fragment. * * Created by xdrush on 2017/1/26. */public class OnAirPageFragment extends BaseItemFragment &#123; private static final int TAB_COUNTS = 10; private static final String[] TITLE = &#123;"常用", "全部", "热门游戏", "移动游戏", "鱼乐星天地", "颜值", "科技", "文娱天堂", "正能量", "体育直播"&#125;; @Override public void initFragment() &#123; for (int i = 0; i &lt; TAB_COUNTS; i ++) &#123; String title = TITLE[i]; mTitleList.add(title); BaseContentFragment fragment = new BaseContentFragment(); fragment.setContent(title); mFragmentList.add(fragment); &#125; &#125; @Override public void setTabLayoutMode() &#123; mTabLayout.setTabMode(TabLayout.MODE_SCROLLABLE); &#125;&#125; 上面涉及到的MainPageFragment和OnAirPageFragment分别是点击底部“首页”和“直播”所对应的页面，其中BaseContentFragment类对应的每个子Tab的Fragment。12345678910111213141516171819202122232425262728/** * 每个Tab对应的Fragment. * * Created by xdrush on 2017/1/26. */public class BaseContentFragment extends Fragment &#123; private TextView mContentTv; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.base_content_fragment_layout, container, false); setupViews(view); return view; &#125; private void setupViews(View view) &#123; mContentTv = (TextView) view.findViewById(R.id.content); &#125; public void setContent(String content) &#123; if (null == mContentTv) &#123; return; &#125; mContentTv.setText(content); &#125;&#125; 对应的xml文件如下：123456789101112131415161718192021222324252627282930313233343536373839// main_content_fragment_layout.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tablayout" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="#389d00" app:tabIndicatorColor="#ffff00" app:tabSelectedTextColor="#CD0000" app:tabTextColor="#ffffff"/&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewpager" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" /&gt;&lt;/LinearLayout&gt;// base_content_fragment_layout.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/content" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="hello world" android:layout_gravity="center"/&gt;&lt;/LinearLayout&gt; 2.2 注意问题可能你会注意到上面有个注释bug/bug fixed，对的，如果采用方法一来实现的话，将会出现下图所示现象： 如上图所示：将会导致indicator和title对不上，整个ViewPager没有回弹过程，导致以上bug。这个问题用方法二即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CTR预估算法之LR]]></title>
      <url>https://xdrush.github.io/2016/12/21/CTR%E9%A2%84%E4%BC%B0%E7%AE%97%E6%B3%95%E4%B9%8BLR/</url>
      <content type="text"><![CDATA[背景伴随着我们浏览器及其矩阵产品用户规模的扩大，单纯的广告接入，然后随机的展示方式无法充分利用我们的广告位，无法达到收益最大化。随着调研的深入，点击率预估模型便提上了日程。 经过前期一个月数据的收集准备，目前的数据量已经能够满足模型的开展了。接下来便会总结一些列关于CTR模型相关的知识，当然这里只对相应算法铺开，限于商业数据的保密性，不对具体数据和实施细节做展开。 整体系统结构我们的模型周级更新，大概结构如下： 系统整体结构图如上，分为offline线下部分和online线上部分。线下部分，取前一周的PV和click日志作为增量训练数据，更新迭代模型；线上部分，利用训练好的模型，接受用户请求，检索广告库（我们的广告库来自于Applovin，Yeahmobi，Mobvista等广告商，天级更新存放在数据库里），组合特征，过CTR，最终取cpm最高的广告进行展示。 LR应用于CTR预估LR算法之why为什么LR算法能够用于CTR预估呢？个人认为主要是一下原因导致的： 把被点击的样本当成正例，把未点击的样本当成负例，那么样本的ctr实际上就是样本为正例的概率，LR可以输出样本为正例的概率，所以可以用来解决这类问题，另外LR相比于其他模型有求解简单、可解释强的优点，这也是工业界所看重的。 关于LR算法pCtr由如下计算方式获取： 上式中，X(j)为第j维特征，pCtr是个概率值。 损失函数采用log最大似然函数，定义如下： 优化目标如下： 优化算法采用SGD，权重更新方式如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习之交叉验证]]></title>
      <url>https://xdrush.github.io/2016/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/</url>
      <content type="text"><![CDATA[1、传统的验证方法机器学习中数据是十分重要的资源，先来看看传统的验证方法，传统的验证方法大概分为4步： 第一步将所有样本分为训练数据和测试数据两部分，假设训练数据占70%，测试数据占30%。训练数据用于训练模型，测试数据用来测试模型性能。 第二步在给定超参数下，用70%的训练数据得到模型。 第三步用剩下的30%测试数据测试严重上述二中得到的模型。 第四步为了不浪费数据，再将所有100%的数据来验证模型，继续修正参数得到最终的模型。 机器学习中数据是最为宝贵的资源的之一，传统的验证方法无法充分利用样本，因此，在传统验证方法基础上，提出了交叉验证思想。 2、交叉验证为使数据得到充分利用，提出了一种优化的交叉验证方法，具体执行步骤如下： 第一步第一步首先将数据分成3部分，训练集、验证集和测试集，假设各占70%、15%、15%， 第二步在同一组训练集上，使用若干个不同的超参数，训练得到不同的模型，如图所示，假设3个模型分别为A、B、C。 第三步在相同的验证集上分别验证上述步骤二中得到的A、B、C，选取最佳超参数所对应的模型。 第四步在上述三所得到的最优模型基础上，继续用训练集和验证集对模型进行进一步优化，进一步修正模型的参数。 第五步在测试集上测试上述四中得到的模型，通常情况下，这时的模型会比较好。 第六步用所有数据继续训练所得到的模型，就是最终的模型。 通过上述步骤，能够充分利用训练样本集，得到最优的模型。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习之Logistic Regression适用性]]></title>
      <url>https://xdrush.github.io/2016/11/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BLogistic%20Regression%E9%80%82%E7%94%A8%E6%80%A7/</url>
      <content type="text"><![CDATA[1 概述Logistic Regression是当前业界比较常用的机器学习方法，用于估计某种事物的可能性。比如某用户够买某商品的可能性，某病人患有某种疾病的可能性，以及某广告被用户点击的可能性。注意：这里的可能性并非数学上的概率，不可以当作概率值来用，但是可能同概率作映射。 2 适用性2.1 可用于概率预测，也可用于分类并不是所有的机器学习方法都可以做可能性概率预测（比如SVM就不行，它只能得到1或者-1）。可能性预测的好处是结果有可比性：比如我们得到不同广告被点击的可能性后，就可以展现点击可能性最大的N个。这样一来，哪怕得到的可能性都很高，或者可能性都很低，我们都能去最优的top N。当用于分类问题时，仅需要设定一个阈值，可能性高于阈值是一类，低于阈值是另一类。 2.2 仅能用于线性问题只有在feature和target是线性关系时，才能用LR（不像SVM那样可以做非线性问题）。这有两点指导意义：一方面当预先知道模型非线性时，果断不能用LR，另一方面，在使用LR时注意选择和target呈线性关系的feature。 2.3 各feature之间不需要满足条件独立假设，但各个feature的贡献是独立计算的LR不像朴素贝叶斯一样需要满足条件独立假设，但每个feature的贡献是独立计算的，即LR是不会自动combine不同的feature产生新的feature的。举个例子，如果你需要TFIDF这样的feature，就必须明确的给出来，若仅仅分别给出两维TF和IDF是不够的，那样只会得到类似aTF+bIDF的结果，而不会有cTF*IDF的效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读书笔记之《特斯拉之父：埃隆·马斯克传》]]></title>
      <url>https://xdrush.github.io/2016/10/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E7%89%B9%E6%96%AF%E6%8B%89%E4%B9%8B%E7%88%B6%EF%BC%9A%E5%9F%83%E9%9A%86%C2%B7%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0%E3%80%8B/</url>
      <content type="text"><![CDATA[算是完完整整读的第一本人物传记了，一直以来比较不屑于读人物传记，主要还是觉得传记之类无非鸡汤而已，总是在看别人的成功故事。“看了那么多成功学的书，依旧得不到成功的一生”，哈哈。 无意在《网易蜗牛读书》上看到了这本书，想着之前在看书时不少因为内容枯燥而不了了之，何不尝试下简单轻松的书看看呢？遂有此篇！ 摘录 总之，说大话的人很难着眼于微小之处；相反，过于自卑而不敢做大事的人，往往目光不够长远。因此，如果一个经营者既能说出前人不敢说也没有想过的话，又能注意到细节，那么，他就有可能成为一个真正的成功者。 太空探索技术公司以出人意料的低成本制造火箭并获得了成功，但是对于成功的秘诀，埃隆解释道：”我们并不是通过革命性的突破取得成功，而是通过孜孜不倦、脚踏实地的努力才取得了今天的成果。”埃隆对太空探索技术公司的”武器“夸耀似的强调说：”我们‘降低成本’的想法本身，就是一种革命性的突破。“ 说出自己的目标并不是件难事，或许还非常简单。就像有些公司往往会给自己设定一个很难达到的目标，为了使股价上升，先说一些豪言壮语。但这种公司的领导者一旦开始行动就会想：“这看起来好像不可能完成啊”，随之懈怠下来，在中途就降低了目标。他们这样做或者是明哲保身，或者是不想让自己的形象印上失败的烙印，畏难和惰性表现得一览无余。但是，领导随意降低目标这种不认真的心态会使员工也没有干劲。 正如亨利·福特通过量产汽车来降低制造成本，埃隆则是通过量产火箭来降低成本。（规模效益） 21世纪的商业竞争中，仅仅提高单件商品的性能很难获得成功。创造出着眼于整体的、方便的体系才是成功的秘诀。 确实，攒钱很难，但更难的是怎样使用攒下的钱。 但埃隆通过网络体验到了创新带来的好处，所以他说：“真正的改革是涉足完全不同的领域”。 总之，要使前所未有的新产品获得广泛的认可，就应该在媒体报道错误时要求修正，该反驳时进行反驳。否则，人们就会不明所以地相信错误的信息，给企业造成不利影响。成立了多家公司的埃隆深知谣言的害处，因此，今后他会继续反击庞大的对手。 一个人想要创造出前所未有的新型产品和服务，若不大力宣扬自己的想法，就不会吸引那些反复无常、懒惰成性的人的注意。所以，开创者就应该使自己的创新引人注目。 商界比拼的就是企业对未来的洞察力，如果企业能准确判断未来，并且真正按照自己的判断去发展，那么它的股价就会迅速上涨。 如果在地球这个有限的空间内人口不断增多、全球变暖不断加剧、环境继续遭到破坏，人类就不能只在地球上生存了。因此，移居到火星也是一种选择。但是，由于人类还没有制造出能飞往火星的飞船，因此要想在飞船制造出来之前获取更长的生存时间，就应该减少二氧化碳和废气排放，普及电动车和太阳能发电就可以达到这个目的。 他也曾偶尔承认，将所有的未来赌在火箭和电动车上很冒险，但他立即话锋一转：“若我不这么投入，才是最大的冒险，因为成功的希望为零。”经历了那段对意志极限的考验后，他总结说：“做企业就像凝视死亡的深渊。” 底特律的传统汽车商不熟悉这个领域，特斯拉却抓住了电池这个关键。 感想这本书出版时，特斯拉的Model S尚未正式交付给客户，然而今天看来，Model S算得上是特斯拉第二代产品，随着Model X这款超跑SUV和Model 3这款价格亲民的电动汽车的上市，从Model 3预定时一车难求这些种种情形来看，无疑，特斯拉成功啦！ 另一方面，书中描述的“猎鹰-9”火箭，已在近两年多次完成发射和回收，并且给国际空间站多次对接、运输必要的器械和食物，无疑，Space X也成功了！ 不仅如此，连他提出的Hyperloop超高速铁路，几年前被大众称之为骗子，被认为是天方夜谭的项目，如今，也在加州如火如荼的进行着，并且已经成功进行了初步实验，可以预期，Hyperloop也正走在成功的路上。 埃隆早起在硅谷从事互联网行业的这段经验，对他后来的创新起到了至关重要的作用。在传统汽车行业从业人士思维被禁锢时，来自互联网人敏锐的洞察力和创新精神，帮助埃隆打破思维禁锢，并一步步践行自己的梦想。 对于梦想的追求，很喜欢这段：“如果在地球这个有限的空间内人口不断增多、全球变暖不断加剧、环境继续遭到破坏，人类就不能只在地球上生存了。因此，移居到火星也是一种选择。但是，由于人类还没有制造出能飞往火星的飞船，因此要想在飞船制造出来之前获取更长的生存时间，就应该减少二氧化碳和废气排放，普及电动车和太阳能发电就可以达到这个目的”。埃隆对于梦想的追求不是一蹴而就的，而是在终极目标无法达到时，退而求其次，曲线救国。有了这个根本宗旨，不至于目标模糊。 不得不说，埃隆是位真正的梦想家和实践家！ 与我而言，得走在正确的路上，脚踏实地的搞点儿事情。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tensorflow使用notes]]></title>
      <url>https://xdrush.github.io/2016/10/17/Tensorflow%E4%BD%BF%E7%94%A8notes/</url>
      <content type="text"><![CDATA[Graph理解Tensorflow的程序一般都分为2个阶段，（1）定义计算图中的所有计算；（2）执行计算； 系统默认计算图在tf程序中，系统会自动维护一个默认的计算图，通过tf.get_default_graph()可以获取当前默认的计算图； 1234567a = tf.constant([2, 3], name='a')b = tf.constant([4, 5], name='b')result = tf.multiply(a, b, name='result')print result.graphprint tf.get_default_graph() 比如上面这段代码的输出为：12&lt;tensorflow.python.framework.ops.Graph object at 0x10eddc2d0&gt;&lt;tensorflow.python.framework.ops.Graph object at 0x10eddc2d0&gt; 可以看到，定义的这些节点都在系统默认的计算图中。 新建计算图tf支持通过tf.Graph生成新的计算图，不同计算图上的张量和运算不会共享，也就是说，tf通过计算图来隔离资源。 Variable及name_space理解对于一个复杂的tensorflow模型可能会有很多变量： tf.variable_scope():提供了简单的命名空间以避免冲突； tf.get_variable():从同一个变量范围内获取或者创建变量； tf.Variable()用于定义一个变量；tf.get_variable()根据name值，返回该变量，如果name不存在的话，则会创建一个变量； tf.variable_scope &amp;&amp; tf.get_variabletf.variable_scope和tf.get_variable，这两个函数通常放在一起使用，tf.variable_scope用于指定变量范围，如果在同一变量范围内，通过tf.get_variable获取已经定义的变量，在没有设置reuse=True时会报错：1234567891011121314with tf.name_scope('a_name_scope'): with tf.variable_scope('scope') as scope: var1 = tf.get_variable(name='var1', shape=[1], dtype=tf.float32, initializer=tf.constant_initializer(value=1))with tf.name_scope('b_name_scope'): with tf.variable_scope('scope', reuse=True): var4 = tf.get_variable(name='var1')with tf.Session() as sess: sess.run(tf.global_variables_initializer()) print(var1.name, sess.run(var1)) print(var4.name, sess.run(var4)) 上面代码给出了通常情况下tf.get_variable和tf.variable_scope用法。reuse=True表示tf.get_variable得到的变量可以在其他地方重复使用，只在需要时设置为True，不设置为False，其中variable_scope的名字可以为空。 特别说明一点，将参数设置为True，这样tf.get_variable()将只能获取已将创建过的变量。 具体说明可以参考这里：http://blog.csdn.net/lanchunhui/article/details/61914287 tf.Graph123456789101112131415161718192021graph1 = tf.Graph() // 新建一个计算图with graph1.as_default(): variable = tf.get_variable("v", shape=[1], dtype=tf.float32, initializer=tf.constant_initializer(value=1)) print variable.graphgraph2 = tf.Graph()with graph2.as_default(): variable = tf.get_variable("v", shape=[1], dtype=tf.float32, initializer=tf.constant_initializer(value=2)) print variable.graphwith tf.Session(graph=graph1) as sess: // 在计算图graph1上执行运算 sess.run(tf.global_variables_initializer()) with tf.variable_scope("", reuse=True): print sess.run(tf.get_variable("v"))with tf.Session(graph=graph2) as sess: // 在计算图graph2上执行计算 sess.run(tf.global_variables_initializer()) with tf.variable_scope("", reuse=True): print sess.run(tf.get_variable("v")) 以上代码的结果为：1234&lt;tensorflow.python.framework.ops.Graph object at 0x114e326d0&gt;&lt;tensorflow.python.framework.ops.Graph object at 0x117b3dcd0&gt;[ 1.][ 2.] 可以看到，变量v在不同的计算图中，它们之间的值也互相不影响。 tf.Graph.device可以通过tf.Graph.device函数来指定运行计算的设备，这为tf提供了GPU的支持，下面的代码可以在GPU上执行：123graph3 = tf.Graph()with graph3.device('/gpu:0'): result = a + b tf.global_variable_initializer()这个函数作用是初始化当前计算图中的全局变量，关于一个tf.global_variable_initializer()用法一个注意的地方：123456weights = tf.Variable(initial_value=tf.random_normal(shape=[2, 3], mean=0.0, stddev=2), name='weights')init_op = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init_op) print sess.run(weights) 上面这段代码可以正确执行，再看下面这段代码：123456init_op = tf.global_variables_initializer()weights = tf.Variable(initial_value=tf.random_normal(shape=[2, 3], mean=0.0, stddev=2), name='weights')with tf.Session() as sess: sess.run(init_op) print sess.run(weights) 这段代码执行时会报错，错误信息如下：1tensorflow.python.framework.errors_impl.FailedPreconditionError: Attempting to use uninitialized value weights 不难发现，tf.global_variable_initializer()须在所有变量都定义之后再去定义。 tf.get_collection()在使用get_collection()时有个地方需要注意，在一次训练过程中，一直出现了这个错误：1234tf.add_n(tf.get_collection('losses'))// error messageraise ValueError("inputs must be a list of at least one Tensor with the " 刚开始也是百思不得其解，后来一检查，发现是regularizer为None，导致tf.get_collection()得到的tensor没有维度，因此tf.add_n时报错。 tf.softmax_cross_entropy_with_logits &amp;&amp; tf.sparse_softmax_cross_entropy_with_logits这两个函数都是用来直接计算交叉熵的，不同的地方是tf.sparse_sotfmax_cross_entropy_with_logits是直接用来处理稀疏性质的数据。 先来看下sotfmax_cross_entropy_with_logits，顾名思义，这个函数是将计算softmax和cross_entropy的过程融合起来了，看下面的代码：1234567891011121314151617// 原始数据，也即labelori_data = tf.constant([0, 1, 0, 0, 0])// 经过softmax之前的输出数据，这里的数据可以呈任意分布，但要保证与label维度相同，这一点也比较好理解predict_data = tf.constant([0.1, 6, 0.1, 0.1, 0.1])// 通过这个函数，不再需要单独计算softmax，然后再分步计算cross_entropy了loss = tf.nn.softmax_cross_entropy_with_logits(labels=ori_data, logits=predict_data)init_op = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init_op) print sess.run(loss) // 输出为：0.0108981 再来看看tf.nn.sparse_softmax_cross_entropy_with_logits，123456ori_data = tf.constant([0, 1, 0, 0, 0])predict_data = tf.constant([0.1, 6, 0.1, 0.1, 0.1])loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=tf.argmax(ori_data, 0), logits=predict_data)// 输出为：0.0108981 可以看到，同上面函数相比，只对label进行了一次加工，而这次加工，正是说明了sparse的特性，tf.argmax(tensor)目的是获取稀疏的tensor中正确答案对应的编号，这个编号是一个整数 tf.app.flags.FLAGStf.app.flags.FLAGS主要用来处理相关输入，特别是在训练中需要动态指定训练数据目录时特别有用。典型用法如下：1234567891011121314import tensorflow as tfFLAGS = tf.app.flags.FLAGStf.app.flags.DEFINE_string('train_dir', './data/train/clsm', 'Directory for event logs and checkpoint')tf.app.flags.DEFINE_string('log_dir', './log/file', 'Directory for log dir')def main(): print FLAGS.train_dir print FLAGS.log_dir passif __name__ == '__main__': main() 这里指定FLAGS.train_dir默认目录为”./data/train/clsm”，如果训练过程中，需要另外指定目录，则通过以下命令即可实现：1python clsm_train.py --train_dir=./data/xdrush/clsm 上面命令将train_dir目录改为./data/xdrush/clsm，但log_dir依旧时默认值。 tf.gfile相关tf封装的文件处理相关模块。123456// 判断文件夹是否存在if tf.gfile.Exists(FLAGS.train_dir): // 递归的删除文件夹 tf.gfile.DeleteRecursively(FLAGS.train_dir)// 创建多层文件夹tf.gfile.MakeDirs(FLAGS.train_dir) tf.records文件读写tf.TFRecordReader &amp; tf.FixedLengthRecordReader上面2个方法都是创建一个Reader来读取TFRecord文件中的样例。其中不同的reader对应不同的文件结构。对于二进制文件，FixedLengthRecordReader就比较好，因为每次读等长的一段数据。 tf.slice()的理解函数原型：tf.slice(inputs, begin, size, name=’’)函数的用途是从inputs中抽取部分内容inputs：可以是list，array，tensorbegin：n维列表，begin[i]表示从inputs中的第i维抽取数据时，相对0的起始偏移量，也就是从第i维的begin[i]开始抽取数据size：n维列表，size[i]表示要抽取的第i维元素的数目1234567891011import tensorflow as tfimport numpy as npprint "test of tf.slice()"y = np.arange(24).reshape([2, 3, 4])print ybegin_y = [1, 0, 1]size_y = [1, 2, 3]out = tf.slice(y, begin_y, size_y)with tf.Session() as sess: print sess.run(out) 输出为：123456789101112## y是一个[2*3*4]的矩阵，输出为：[[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] ## 最终结果为： [[[13 14 15] [17 18 19]]] begin_y = [1, 0, 1]分别表示从第一维的第二个元素开始抽取，0表示从第二维的第一个元素开始抽取，1表示从第三维的第1个元素开始抽取；size_y = [1, 2, 3]表示第一维抽取一个，第二维抽取2个，第三维抽取3个；不难得出最终的结果。 如果数据不足，则会报错。比如如果将begin_y = [1, 0, 2]，表示从第三位的第三个元素开始抽取，抽取个数维3，而此时第三维只剩下2个元素，因此会报错。1InvalidArgumentError (see above for traceback): Expected size[2] in [0, 2], but got 3 tf.transpose()的理解tr.transpose(a, perm=None, name=’’)默认情况下，如果不指定perm值，则该函数完成矩阵转置功能：123456789101112131415matrix = np.arange(12).reshape([3, 4])print "original matrix: \n", matrixwith tf.Session() as sess: print sess.run(tf.transpose(matrix))## 输出为original matrix: [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] 接下来主要看下perm的含义：1234matrix = np.arange(24).reshape([2, 3, 4])print "original matrix: \n", matrixwith tf.Session() as sess: print sess.run(tf.transpose(matrix, perm=[0, 1, 2])) 对于多维矩阵，当perm=[0, 1, 2]时，输出结果与原矩阵一样；当perm=[2, 1, 0]时，实现的就是标准的矩阵转置。由此可知，perm控制的转置的维度。 tf.split()的理解沿着某一维度将输入切割成多等份。tf.split(value, num_or_size_split, axis=0, num=None, name=’’)value：输入的tensornum_or_size_split：切割的数量，可以是矩阵axis：切割的维度，0表示按行切分，1表示案列切分num：默认值不用管12345678910111213141516171819matrix = np.arange(12).reshape([3, 4])// 表示将第二维切成4等份split_result = tf.split(matrix, 4, 1)print "original matrix: \n", matrixwith tf.Session() as sess: result = sess.run(split_result) print result## 输出为[array([[0], [4], [8]]), array([[1], [5], [9]]), array([[ 2], [ 6], [10]]), array([[ 3], [ 7], [11]])] 当num_or_size_split为矩阵时，1234567891011121314matrix = np.arange(12).reshape([3, 4])// 表示将第二维切成1:3的两部分split_result = tf.split(matrix, [1, 3], 1)print "original matrix: \n", matrixwith tf.Session() as sess: result = sess.run(split_result) print result// 输出结果为：[array([[0], [4], [8]]), array([[ 1, 2, 3], [ 5, 6, 7], [ 9, 10, 11]])] tensorflow与GPUtf.ConfigPrototf.ConfigProto在多GPU机器上的配置信息，比较重要。 tensorflow与layerstf.layers模块里面包含tf定义的一些层，包括全连接层，池化层等。 tf.layers.max_pooling2d1234def max_pooling2d(inputs, pool_size, strides, padding='valid', data_format='channels_last', name=None): 类似的还包括max_pooling1d, max_pooling3d，用法可查文档。 tf.layers.dense定义的是全连接层。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TensorFlow中的initializer]]></title>
      <url>https://xdrush.github.io/2016/09/08/TensorFlow%E4%B8%AD%E7%9A%84initializer/</url>
      <content type="text"><![CDATA[1 TensorFlow中的initializerTensorFlow中集成有多个initializer，这些initializer对tensorflow中变量的初始化提供了方便，下面将对这些initializer进行介绍： 1.1 truncated_normal_initializer中文称作截断正太分布，具体意义可自行查阅相关资料。123tensor = tf.get_variable("tensor", shape=[3, 4], initializer=tf.truncated_normal_initializer(mean=5.0, stddev=0)) TensorFlow文档中对这个initializer说明如下：1234These values are similar to values from a `random_normal_initializer` except that values more than two standard deviations from the mean are discarded and re-drawn. This is the recommended initializer for neural network weights and filters. 可以看出，TensorFlow推荐使用这个initializer对权重和过滤器进行初始化。 1.2 random_normal_initializer随机正太分布，可以指定均值和方差。123456789101112tensor = tf.get_variable("tensor", shape=[3, 4], initializer=tf.random_normal_initializer(mean=5.0, stddev=0.1)) sess = tf.Session()sess.run(tf.global_variables_initializer())print sess.run(tensor)# output[[ 4.97685289 5.06061602 4.92227983 4.94275761] [ 5.0433836 5.07488203 4.89840937 5.08210135] [ 4.88602161 4.9784441 4.9026494 4.94235086]] 1.3 random_uniform_initializer随机均匀分布，凡是uniform_initializer都是某种均匀分布。12345678tensor = tf.get_variable("tensor", shape=[3, 4], initializer=tf.random_uniform_initializer(minval=-1, maxval=1))# output[[-0.43593144 -0.7915628 -0.79432058 -0.70454049] [ 0.94479799 -0.89193916 0.13897324 0.15223503] [ 0.22761178 0.26544452 0.71627235 -0.87396431]] 1.4 constant_initializer顾名思义，用常量来初始化变量。12345678tensor = tf.get_variable("tensor", shape=[3, 4], initializer=tf.constant_initializer(5))# output[[ 5. 5. 5. 5.] [ 5. 5. 5. 5.] [ 5. 5. 5. 5.]] 1.5 ones_initializer全1的initializer，将变量全部赋值为1.12345678tensor = tf.get_variable("tensor", shape=[3, 4], initializer=tf.ones_initializer())# output[[ 1. 1. 1. 1.] [ 1. 1. 1. 1.] [ 1. 1. 1. 1.]] 1.6 zeros_initializer全0的initializer，将变量全部赋值为0.12345678tensor = tf.get_variable("tensor", shape=[3, 4], initializer=tf.zeros_initializer())# output[[ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.]] 以上介绍了几种常用的initializer，其他的initializer可查阅官网。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Numpy学习笔记]]></title>
      <url>https://xdrush.github.io/2016/05/17/Numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="text"><![CDATA[1、数组和矢量计算利用数组进行统计处理 meshgrid meshgrid()用于从数组a和b产生网格，生成的网格矩阵A和B大小相同，123a = np.arange(-2, 2, 1)b = np.arange(3, 6, 1)A, B = numpy.meshgrid(a, b) 生成size(a)*size(b)大小的矩阵，相当于把a从一行重复增加到size(b)行，把b转置成一列再重复增加到size(a)列。 wherenp.where函数是三元表达式x if conditoin else y的矢量化版本。12345xaar = np.array([1.1, 1.2, 1.3, 1.4, 1.5])yaar = np.array([2.1, 2.2, 2.3, 2.4, 2.5])# cond为true时，选取xaar中的元素，否则选取yaar中的元素cond = np.array([True, False, True, False, True])result = np.where(cond, xaar, yaar) where的第二个和第三个参数不必是数组，也可以是标量值。在数据分析中，where通常用语根据一个数组产生另外一个新的数组。 假设有一个随机数据组成的矩阵，将其中的正数替换为2，负数替换为-2，12345678aar = np.random.randn(4, 4)# 正数替换为2，负数替换为-2result = np.where(aar &gt; 0, 2, -2)# 只将正数替换为2result = np.where(aar &gt; 0, 2, aar)print result 数学和统计方法可以通过数组上的一组函数对整个数组或者某个轴向的数据进行统计计算。sum、mean、以及标准差等聚合计算既可以当作数组的实例方法调用，也可以当作numpy的顶级函数使用。12345678910arr = np.random.randn(5, 4)print arr.mean() # equals np.mean(arr)print arr.sum()print arr.mean(axis=0) # equals arr.mean(0)arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])# 按行计算所有元素的累计和result = arr.cumsum(1)# 按列计算所有元素的累计积result = aar.cumprod(0) 其他函数有：123std、var：标准差和方差min、max：最大值和最小值argmin、argmax：最小和最大元素的索引 用于布尔型数组的方法sum()经常用来对布尔型数组中的True值计数：123arr = np.random.randn(10)# arr中正数的数量result = (arr &gt; 0).sum() 另外，any()用语测试数组中是否存在一个或者多个True，all则检测数组中所有值是否都是True。123bools = np.array([False, True, False, True])result1 = bools.any() # Trueresult2 = bools.all() # False 排序跟python内置的列表类型一样，numpy数组也可以通过sort方法进行就地排序：12345678910arr = np.random.randn(8)print arrarr.sort()print arrarr = np.random.randn(5, 3)print arr# 多维数组列排序arr.sort(0)print arr np.sort()返回的是数组得已排序副本，而就地排序则会修改数组本身。 唯一化以及其他的集合逻辑np.unique，用于找出数组中的唯一值并返回已排序的结果。1234arr = np.array([1, 2, 4, 2, 10, 9, 5, 3])# 相当于返回所有出现过的元素，并返回只出现一次的结果result = np.unique(arr)print result # 1, 2, 3, 4, 5, 9, 10 2、用于数组的文件输入输出numpy能够读写磁盘上的文本数据和二进制数据。 将数组以二进制格式保存np.save()和np.load()是读写磁盘数组数据的两个主要函数。默认情况下，数组以未压缩的原始二进制格式保存在扩展名为.npy的文件中。1234567arr = np.arange(10)print arr# 如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上np.save('some_array', arr)result = np.load('some_array.npy')print result np.savez()用于将多个数组保存到一个压缩文件中，将数组以关键字参数的形式传入即可：1234arr1 = np.arange(5)np.savez('arrays', a=arr, b=arr1)arch = np.load('arrays.npz')print arch['b'] 线性代数 矩阵乘法123x = np.array([[1, 2, 4], [4, 5, 6]])y = np.array([[1, 2], [3, 4], [5, 6]])print x.dot(y) # equals np.dot(x, y) numpy.linalg中有一组标准得矩阵分解运算以及诸如求逆和行列式之类得方法。12345678910x = np.random.randn(5, 5)mat = x.T.dot(x)# 计算逆矩阵print np.linalg.inv(mat)print mat.dot(np.linalg.inv(mat))# 计算QR分解q, r = np.linalg.qr(mat)print q 一些其他常用的函数说明：（1）trace：计算对角线元素的和（2）det：计算行列式（3）svd：计算奇异值分解（4）solve：解线性方程主Ax=b… 4、随机数生成numpy.random模块对python内置的randon进行了补充，增加了一些用于高效生成多种概率分布的样本值函数。 normal得到服从标准正态分布得随机数。 12samples = np.random.normal(size=(4, 5))print samples shuffle对一个序列就地随机排列 binomial产生二项分布得样本值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu下Boost.Python环境配置]]></title>
      <url>https://xdrush.github.io/2016/05/04/ubuntu%E4%B8%8BBoost.Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[1 说明Python很强大，但已有的模块可能满足不了所有的场景需求，于是有时需要编写扩展模块进行完善。Boost无疑是开发最快的一种方案。 2 Boost.Python环境配置2.1 安装Python、BoostPython安装不再细述，ubuntu下安装boost只需一行命令即可。1sudo apt-get install libboost-dev 安装完成之后，用下面这段代码测试：1234567891011121314#include &lt;iostream&gt;#include &lt;boost/lexical_cast.hpp&gt;using namespace std;int main()&#123; string s = "100"; int a = boost::lexical_cast&lt;int&gt;(s); int b = 1; cout &lt;&lt; (a + b) &lt;&lt; endl; return 0;&#125; 运行成功则说明Boost环境已经搭建好啦。 3利用C++ Boost编写Python模块3.1 源文件编写12345678910111213141516#define BOOST_PYTHON_SOURCE#include &lt;boost/python.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace boost::python;void hello_func()&#123; cout&lt;&lt;"hello boost"&lt;&lt;endl;&#125;BOOST_PYTHON_MODULE(boostpy)&#123; def("Hello", hello_func, "function targets...");&#125; 3.2 编译为动态库在命令行中执行：1234g++ -shared -o boostpy.so -fPIC -I /YourPythonIncludePath/ helloworld.cpp -lpython2.6 -lboost_python// 以本人电脑为例，进入到helloworld.cpp文件所在目录，执行：g++ -shared -o boostpy.so -fPIC -I /usr/include/python2.7/ helloworld.cpp -lpython2.7 -lboost_python 其中，YourPythonIncludePath为本地python库的路径。执行这一步过程中，可能报这个错误：12/usr/include/boost/python/detail/wrap_python.hpp:50:23: fatal error: pyconfig.h: No such file or directory 这个错误一般就是由于上面YourPythonIncludePath配置不对导致的。当然，不过不想每次都加上这个路径，可以将其配置到环境变量中：1export CPLUS_INCLUDE_PATH=&quot;$CPLUS_INCLUDE_PATH:/usr/include/python2.7/&quot; 这一步配置正确了，可能还会遇到以下这个问题：1library not found for lboost_python 用locate命令查找下boost_python.so，确实没有这个文件，1sudo apt-get install libboost-python-dev 执行上述命令安装这个库即可。 以上所有步骤都正确则会在当前目录中生成一个boostpy.so文件，这个文件即是python中的模块。 3.3 python加载模块在python中直接import这个module即可使用：123&gt;&gt;&gt; import boostpy&gt;&gt;&gt; boostpy.Hello()hello boost python 4 References[1] http://stackoverflow.com/questions/33471055/library-not-found-for-lboost-python[2] http://stackoverflow.com/questions/19810940/ubuntu-linking-boost-python-fatal-error-pyconfig-cannot-be-found]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ActivityThread & Instrumentation在MultiDex实现中的应用]]></title>
      <url>https://xdrush.github.io/2016/04/27/ActivityThread%20&%20Instrumentation%E5%9C%A8MultiDex%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="text"><![CDATA[背景说明这篇文章可以看作是对MultiDex实践的一篇补充，更进一步的背景是对美团MultiDex实现的一些具体细节的一种实现方式。 同美团团队一样，在实现MultiDex时，同样遇到一个问题，那就是：部分在classes2.dex中的二级界面，首次启动时，如果classes2.dex尚未加载完，而这时用户操作了该二级界面，Crash！！是必然的！美团的那篇文章也讨论了这个问题，解决方法就是在操作二级界面Activity时，首先判断classes2.dex是否加载完毕，如果加载完毕，则直接启动该Activity，如果尚未加载完毕，则引入一个WaitActivity，在WaitActivity中阻塞等待classes2.dex加载完成，等dex2加载完毕之后再启动该二级界面Activity。 这么做肯定是没有问题的，但有一点就是，如果二级界面太多，每个调用的地方都去判断dex2是否加载完未免太麻烦，好在Framework告诉了我们答案！我们知道Activity是由ActivityThread通过Instrumentation来启动的，再进一步跟进去，我们发现ActivityThread中有一个mInstrumentation对象，该对象即是Instrumentation，进一步查看Instrumentation源码，发现其与Activity启动相关的方法有以下几个：execStartActivity, newActivity等等，于是，我们就可以在这里面做些手脚！怎么做？修改Instrumentation或者ActivityThread也未免显得太过幼稚了！那么How？方法其实很简单：(1)自定义MyInstrumentation继承自Instrumentation；(2)通过放射方式在应用刚启动时以MyInstrumentation替换掉ActivityThread中的mInstrumentation，替换的时机最好实在Application.attachBaseContext()中。 自定义Instrumentation首先自定义MyInstrumentation继承自Instrumentation，在newActivity中作判断该Activity是否加载完，代码如下：123456789101112public class MyInstrumentatin extends Instrumentation &#123; @Override public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Log.d(TAG, className); if (isActivityInDex2() &amp;&amp; !isDex2Installed) &#123; className = "com.myapp.WaitActivity"; &#125; return (Activity)cl.loadClass(className).newInstance(); &#125;&#125; 有了这关键的一步，WaitActivity的实现细节这里就不作多述，有兴趣的可以私我！ 注册MyInstrumentation实现了MyInstrumentation，剩下的就是以MyInstrumentation替换掉系统的Instrumentation，实现如下：123456789101112131415161718192021222324252627public class MyApplication extends Application &#123; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); registerMyInstrumentation(); &#125;&#125;/*** 反射方式替换掉系统Instrumentation.*/public static void registerMyInstrumentation() &#123; try &#123; Class activityThreadClass = Class.forName("android.app.ActivityThread"); Field instrumentationField = activityThreadClass.getDeclaredField("mInstrumentation"); instrumentationField.setAccessible(true); MyInstrumentation myInstrumentation = new MyInstrumentation(); Method getActivityThread = activityThreadClass.getDeclaredMethod("currentActivityThread"); Object object = getActivityThread.invoke(null); instrumentationField.set(object, myInstrumentation); &#125; catch (Exception e) &#123; Log.e(TAG, e.toString()); &#125;&#125; 至此，比较完备的MultiDex实现方式算是告一段落了，整个过程，给我最大的感受就是：Read the Fucking Source Code是多么重要！RTFSC过程中，不仅能学到别人代码的组织形式，更重要的是能够从根本上为解决某些问题提供思路！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java进阶之SOLID原则]]></title>
      <url>https://xdrush.github.io/2016/04/24/Java%E8%BF%9B%E9%98%B6%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/</url>
      <content type="text"><![CDATA[1. 什么是SOLID原则？S.O.L.I.D原则是面向对象设计和编程中几个重要的编码原则首字母的缩写；SRP：The Single Responsibility Principle，单一职责原则OCP：The Open Closed Principle，开放封闭原则LSP：The Liskov Substitution Principle，里氏替换原则ISP：The Interface Segregation Principle，接口分离原则DIP：The Dependency Inversion Principle，依赖倒置原则下面将详细讲解每种原则所代表的意义。 2. SRP（单一职责原则）当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。 3. OCP（开放封闭原则）软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。 通过增加代码来扩展功能，而不是修改已经存在的代码。 若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。 OCP支持替换的服务，而不用修改客户模块。 示例如下：1234567891011public boolean sendByEmail(String addr, String title, String content) &#123;&#125;public boolean sendBySMS(String addr, String content) &#123;&#125;// 在其它地方调用上述方法发送信息sendByEmail(addr, title, content);sendBySMS(addr, content); 如果现在又多了一种发送信息的方式，比如可以通过微信来发送信息，那么不仅需要增加一个方法sendByWeChat()，还需要在调用它的地方进行修改，违反了OCP原则，更好的方式是抽象出一个Send接口，里面有个send()方法，然后让SendByEmail和SendBySMS去实现它既可。这样即使多了一个通过WeChat发送的请求，那么只要再添加一个SendByWeChat实现类实现Send接口既可。这样就不需要修改已有的接口定义和已实现类，很好的遵循了OCP原则。12345678910111213141516171819202122232425262728public interface Send &#123; void send(String addr, String title, String content);&#125;public class SendByEmail implements Send &#123; @Override public void send(String addr, String title, String content) &#123; System.out.println("SendByEmail"); &#125;&#125;public class SendBySMS implements Send &#123; @Override public void send(String addr, String title, String content) &#123; System.out.println("SendBySMS"); &#125;&#125;public class SendByWeChar implements Send &#123; @Override public void send(String addr, String title, String content) &#123; System.out.println("SendByWeChar"); &#125;&#125; 如此，即很好的满足了OCP原则。 4. LSP（里氏替换原则）当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法； 子类中可以增加自己特有的方法； 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松； 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 举个简单的例子来说明，我们需要完成一个两数相减的功能，由类A来负责：12345678910111213class A &#123; public int func1 (int a, int b) &#123; return a - b; &#125; &#125; public class Client &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println("100 - 50 = " + a.func1(100, 50)); System.out.println("100 - 80 = " + a.func1(100, 80)); &#125; &#125; 后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能： 两数相减。 两数相加，然后再加100。 由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：123456789101112131415161718class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125; public int func2(int a, int b) &#123; return func1(a, b) + 100; &#125; &#125; public class Client&#123; public static void main(String[] args) &#123; B b = new B(); System.out.println("100 - 50 = " + b.func1(100, 50)); System.out.println("100 - 80 = " + b.func1(100, 80)); System.out.println("100 + 20 + 100 = " + b.func2(100, 20)); &#125; &#125; 运行，不难发现肯定是无法获得正确的结果的，这就印证了上述观点。 5. ISP（接口分离原则）不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口要好。 客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。这里比较好理解，就不举例啦。 6. DIP（依赖注入或倒置原则） 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 抽象不应该依赖于细节，细节应该依赖于抽象 先让我们从宏观上来看下，举个例子，我们经常会用到宏观的一种体系结构模式–layer模式，通过层的概念分解和架构系统，比如常见得三层架构等。那么依赖关系应该是自上而下，也就是上层模块依赖于下层模块，而下层模块不依赖于上层，如下图所示。 这应该还是比较容易理解的，因为越底层的模块相对就越稳定，改动也相对越少，而越上层跟需求耦合度越高，改动也会越频繁，所以自上而下的依赖关系使上层发生变更时，不会影响到下层，降低变更带来的风险，保证系统的稳定。上面是立足在整体架构层的基础上的结果，再换个角度，从细节上再分析一下，这里我们暂时只关注UI和Service间的关系，如上面UI和Service这样的依赖关系会有什么样的问题？ 当需要追加提供一种新的Service时，我们不得不对UI层进行改动，增加了额外的工作。 这种改动可能会影响到UI，带来风险。 改动后，UI层和Logic层都必须重新再做Unit testing。 那么具体怎么优化依赖关系才能让模块或层间的耦合更低呢？想想前面讲的OCP原则吧，观点是类似的。我们可以为Service追加一个抽象层，上层UI不依赖于Service的details，UI和Service同时依赖于这个Service的抽象层。如下图是我们的改进后的结果。这样改进后会有什么好处呢？ Service进行扩展时，一般情况下不会影响到UI层，UI不需要改动。 Service进行扩展时，UI层不需要再做Unit testing。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MultiDex实践]]></title>
      <url>https://xdrush.github.io/2016/04/10/MultiDex%E5%AE%9E%E8%B7%B5/</url>
      <content type="text"><![CDATA[Why MultiDex?Android应用65535方法数的限制一直为广大开发者所诟病，在应用功能越来越丰富、各种开源库越来越多的今天，65k方法数瓶颈俨然已是一大绊脚石。至于怎么解决这个问题，先来看看google官方给出的方案： 插件化 将应用的非核心功能做成单独的App，实现该App和插件App相关的接口即可，实现以及体验如何，大家不妨来体验下Dolphin浏览器（这里做个小广告）。 MultiDex 多dex实现，对大多数App，解压其apk，一般只有一个classes.dex文件，采用MultiDex的App解压可以看到有classes.dex,classes2.dex,…classes(N).dex，这样每个dex都可以最大承载65535个方法，很大限度的解决了单dex方法数限制。 下文将详细介绍MultiDex如何实现。 MultiDex初步实现google官方MultiDex实现Google官方MultiDex实现用起来比较简单： gradle中添加MultiDex支持 1multiDexEnable true 加载classes2.dex AndroidManifest.xml的application中添加MultiDexApplication，或者如果已经重载Application，则在onAttachBaseContext()中执行MultiDex.install()即可加载dex2。 官方方案简单易用，但遗留的问题也不少，具体注意事项可以google官文有很详细的阐述，这里不再讨论，但使用时有一点需要注意，那就是只有在应用方法数接近65k(注意是接近65k而非确切的65k，之所以提到是因为这个坑导致了线上一个版本hotfix)时才会打包为2个dex文件，具体超过多少个方法数会打包多个dex可以通过设置dx的’–set-max-idx-number’来决定。 MultiDex初步应用最初版本，App还只是超过65535大概上百个方法，就按google官方方案对App进行多dex支持，启动发现无任何异常(包括启动速度、启动ANR、Crash等)，classes2.dex也只有带该二三十KB大小，暗自窃喜了一小阵子！好景不长，随着下一个版本一个新的SDK的引入，导致classes2.dex文件达到了200KB，测试发现不少机型启动ANR或者crash，或者启动时间过长，再次去看了google提出的MultiDex存在的问题，嗯，发现基本都是描述的那些问题！ 接下来在上个版本的基础上稍作改动，先来看下App启动流程：12Application.attachBaseContext()-&gt;Application.onCreate() -&gt; MainActivity.onCreate -&gt;MainActivity.onStart() -&gt; MainActivity.onResume() 不难发现，Application.attachBaseContext是我们能控制的最早执行的代码，在这个方法里面执行MultiDex.install()无疑是最佳时机。还有一点我们需要了解，Dalvik虚拟机首次启动对classes.dex执行DEXOPT操作非常耗时，而执行MultiDex.install()必然会再次对classes2.dex执行DEXOPT等操作，所有这些操作必须在5s内完成，否则ANR给你看！非首次启动则直接从cache中读取已经执行过dexopt的文件ODEX，这个过程对启动并无太大影响（测试中发现首次启动dex2加载需要1~2s，非首次启动几十ms左右），这也大概就是为什么classes2.dex不能太大的一个原因。基于此，对attachBaseContext稍作改动： 123456789101112131415161718192021@Overrideprotected void attachBaseContext(final Context base) &#123; super.attachBaseContext(base); // TODO: your init code here. initOperationBeforeDex2Installed(); boolean isAppFirstLaunch = FirstLaunchManager.getInstance().firstLaunch(); if (isAppFirstLaunch) &#123; // 首次启动 new Thread(new Runnable() &#123; @Override public void run() &#123; MultiDex.install(base); // TODO: your init code here, some init operation of which some classes were divided into dex2. initOperationAfterDex2Installed(); &#125; &#125;).start(); &#125; else &#123; // 非首次启动 MultiDex.install(base); // TODO: your init code here, some init operation of which some classes were divided into dex2. initOperationAfterDex2Installed(); &#125;&#125; 以上逻辑便是改动之后的初步实现，首次启动开启一个线程来加载dex2，防止阻塞UI线程，非首次启动则同步执行；initOperationAfterDex2Installed()方法是根据Classes2.dex中结果，将涉及到的相关初始化工作移到dex2加载完之后执行，避免启动问题。当然这么做还不够，现在很多App在首次启动时引入闪屏页，我们的App首次启动也有一个FirstLaunchActivity来实现闪屏，闪屏结束之后就进入MainActivity，在进入MainActivity之前，运行一段阻塞代码来判断dex2是否加载完毕，如果dex加载完成，则立即进入MainActivity，如果尚未加载完毕，则阻塞等待dex2加载完毕，这么做主要还是为了避免启动过程中的ANR/Crash。 MultiDex引起的ANR/CrashANR！！Crash！！对，这就是MultiDex引起的坑！通过以上方法初步实现了MultiDex，但时不时QA就来找我：“这个机型ANR了”，“这个机型又ANR了”，“这个机型怎么又Crash了”，“这个手机启动不了”，简直令人抓狂！云测试通过率也没之前的高！实际上所有这些都是同一个问题导致的：dex2没加载完成之前，程序调用了dex2中的类或者方法！adb logcat看下，基本也就是4类问题引起的：1234(1) NoClassDefFoundError(2) Could not find class(3) Could not find method(4) NDK Error 这里需重点讨论下NDK error，这种问题是在有JNI调用的时候才会发生，并且出现的比较诡异，我也是在云测试的时候才注意到这个问题的严重性，通过观察启动的log，查找SIGSEGV，died等关键字，发现在这些关键字附近会有诸如“unable to find **”，其实这里就是没有找到的类引起的NDK error的关键所在，解决方法当然就是将这些类放到classes.dex中。个人建议在用MultiDex时，多次启动看logcat，重点关注以上3个类型的信息！知道了哪些类引起的错误之后，只需将这些类强制分到classes.dex中即可。那么如何实现呢？这里还得简要了解下MultiDex编译过程以及涉及到分包的几个重要task。 MultiDex编译过程gradle task简介限于篇幅这里不对gradle、groovy作介绍，想了解的google上有不少好资料，这里只简要介绍gradle中的task以及MultiDex编译过程中重要的几个task，这是最终MultiDex实现的关键。 task，顾名思义就是任务的意思，是执行Project构建的基本单位，一个工程所有的构建最终是由一个个task来完成，这里我们来分析一个简单的build日志（PS：当我们输入gradle build按下Enter之后，屏幕上biu的一下多了不少日志信息，实际上这些日志信息就是一个个task的输出信息，阅读build日志对我们理解整个工程的构建大有裨益），以下面一段build日志为例：123456MyProject:generateReleaseSourcesMyProject:processReleaseJavaResMyProject:compileReleaseNdk UP-TO-DATEMyProject:compileReleaseSourcesMyProject:collectReleaseMultiDexComponentsMyProject:proguardRelease 日志中，generateReleaseSources、processReleaseJavaRes…、proguardRelease都是构建过程中依次执行的task任务，这些task分别完成不同的功能，欲知更多task信息，RTFSC无疑是不二选择，gradle相关task源码请移步这里。MultiDex编译过程最重要的task主要有3个： collect{Release/Debug}MultiDexComponents这个task扫描AndroidManifest.xml文件中的application、activity、receiver、provider、service等相关类，这将这些类信息写入到manifest_keep.txt文件中，该文件位于build/intermediates/multi-dex/{release/debug}目录下。 shrink{Release/Debug}MultiDexComponents这个task会根据proguard规则以及manifest_keep.txt文件来进一步优化manifest_keep.txt，将其中没有用到的类删除，最终生成componentClasses.jar文件，该文件同样位于build/intermediates/multi-dex/{release/debug}目录下。 create{Release/Debug}MainDexClassList这个task会根据上步中生成的componentClasses.jar文件中的类，递归扫描这些类所有相关的依赖类，最终形成maindexlist.txt文件，该文件也位于build/intermediates/multi-dex/{release/debug}目录下，这个文件中的类最终会打包进classes.dex中。需要注意的是，maindexlist.txt文件并没有完全列出有所的依赖类，如果发现要查找的那个class不在maindexlist中，也无需奇怪。如果一定要确保某个类分到主dex中，将该类的完整路径加入到maindexlist中即可，这里要注意，如果加入的类并不在project中，则gradle构建会忽略这个类，如果加入了多个相同的类，则只取其中一个。这3个task在build日志中都能找到。 MultiDex ANR/Crash解决方法知道了上面的几个task，回到前面的问题：如何将某个类强制打包到classes.dex中？上面的3个task已经给出了答案！对，只需将该类完整路径添加到maindexlist.txt文件中即可！create{Debug/Release}MainDexClassList这个task正是实现这个操作的关键，主要代码如下：12345678910111213141516171819tasks.whenTaskAdded &#123; task -&gt; if (task.name.startsWith("create") &amp;&amp; task.name.endsWith("MainDexClassList") &#123; task.doLast &#123; File tempFile File keepFile if (task.name.contains("Debug")) &#123; tempFile = new File("$project.rootDir/MyProject/keep_in_maindexlist_debug.txt") keepFile = new File("$&#123;project.buildDir&#125;/intermediates/debug/maindexlist.txt") &#125; else if (task.name.contains("Release")) &#123; tempFile = new File("project.rootDir/MyProject/keep_in_maindexlist_release.txt") keepFile = new File("&#123;project.buildDir&#125;/intermediates/release/maindexlist.txt") &#125; tempFile.eachLine("utf-8") &#123; str, linenumber -&gt; keepFile.append(str + "\n") &#125; &#125; &#125;&#125; 这里将需要强制分到classes.dex中的类放在keep_inmaindexlist{debug/release}.txt，这种实现方式基本能够解决眼前问题，但现在看来还是略显too simple too navie！主要问题是不可控性，任何一次对代码的改动都有可能导致不同的分包结果，这就可能隐藏着不同的类导致首次启动失败，大量测试结果事实上也证明了这种方法的不可控性。作为开发，代码的不可控性无疑无法忍受，如何改进这种方法使得MultiDex可控呢？与Dev Lead交流之中间接找到了一种改进的方案，下文细述这个方法。 MultiDex的一种改进实现那么该如何让MultiDex分包可控呢？我的做法是：找出启动过程中所有类及依赖类，强制放入到classes.dex中！这么做要求启动类不能太多(实际上大部分App从启动Application到进入MainActivity也就几个直接类)，同时尽量让主界面和二级界面充分解耦，如果不想对现有代码做太多改动，一种做法是以反射方式调用二级界面中的Activity(因为反射找不到依赖关系)，不过调用时得要先判断classes2.dex是否加载完，以防某些二级界面相关代码在classes2.dex中而引起的crash，这么做虽然对功能实现上并无影响，但可能导致代码可维护性降低。另外还有一点就是，我们可以控制哪些类在classes.dex中，但无法控制哪些类分到classes2.dex中(通过dx打包的方式就另当别论了)，以反射方式调用二级界面activity可以增大二级界面相关类分到dex2中的概率。 寻找启动类如何找出App启动到主界面显示这个过程中的所有类？网上能够找得到的方法比较少，美团有自己的脚本程序找启动依赖类，但人家没开！源！！啦！！！还好google找到了CDA(Class Dependency Analyzer)，通过这个工具，基本都能找到启动过程中所有Activity、Application等相关依赖类，通常会有一定偏差(会将某些系统方法也找出来了)，这时还需结合App的所有类来作进一步优化(获取App所有类只需反编译dex文件形成jar，解压jar包，再用shell相关工具处理即可得到)，取两者的交集基本就能找出所有启动依赖类了。这里有一点需注意：必须以debug版本的App来分析，下文会讲到为什么。 Release版本寻找启动类为什么要将Release版本单独拿出来说呢？对，就是因为混淆！混淆可能会导致每次编译形成的class文件名不同，代码的增加或者减小也会对混淆结果产生影响，这就可能导致每次编译所需的启动类名都不一样，而Debug版本因为不会进行代码混淆，因此启动过程中的类名基本变化不大。那么问题来了，如何确定Release版本启动依赖类呢？build日志！！对，通过编译日志，我们发现，proguard{Release/Debug}这个task在create{Release/Debug}MainDexClassList这个task之前执行，这意味着，在形成maindexlist之前，我们能够确切的知道哪些类进行了混淆以及混淆之后的类名！如何获知？proguard的产物给出了答案：build/outputs/mapping/release/目录下的4个txt文件就是proguard的产物：1234dump.txt:所有class文件的内部结构mapping.txt：源码与混淆之后的类、方法、属性名字之间的一一映射关系seeds.txt：未被混淆的类和属性usage.txt：从Apk中剥离的代码 这里mapping.txt文件正是我们需要的，至于另外的3个文件有兴趣的可以研究下。我们来看下mapping.txt中文本的结构：12345678android.support.ActivityManagerCompat -&gt; android.support.a: 48:52:int getLargeMemoryClass() -&gt; a 62:83:boolean isHighEndGfx(android.content.Context) -&gt; aandroid.support.ClipboardManagerCompat -&gt; android.support.b: 29:32:android.support.ClipboardManagerCompat getInstance(android.content.Context) -&gt; a java.lang.CharSequence getText() -&gt; a void setText(java.lang.CharSequence) -&gt; a boolean hasPrimaryClip() -&gt; b 从上述信息中，我们知道经过代码混淆，android.support.ActivityManagerCompat在release版中最终打包为android.support.a类，并且对其中的方法也进行了混淆。并且注意到，文本中对类混淆的行已”:”结尾，这下问题就有解了，根据startup_keep_list_debug.txt文件中的每一行，在mapping.txt中寻找其是否被混淆，如果被混淆了，则读取经过混淆的类，如果没有被混淆，则直接获取该类，通过这几个步骤，即可形成最终Release版本的启动依赖类，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if (task.name.startsWith("create") &amp;&amp; task.name.endsWith("MainDexClassList")) &#123; task.doLast &#123; println "create MainDexClassList" File debugStartupFile = new File("$project.rootDir/MyProject/startup_keep_list_debug.txt") if (task.name.contains("Debug")) &#123; keepFile = new File("$&#123;project.buildDir&#125;/intermediates/multi-dex/debug/maindexlist.txt") // 情况maindexlist.txt FileWriter fileWriter = new FileWriter(keepFile) fileWriter.write("") fileWriter.close() // 写入启动依赖类到maindexlist.txt中 debugStartupFile.eachLine("utf-8") &#123; str, linenumber -&gt; keepFile.append(str + "\n") &#125; &#125; else if (task.name.contains("Release") &#123; File startupFile = new File("$&#123;project.buildDir&#125;/intermediates/multi-dex/release/maindexlist.txt") FileWriter fileWriter = new FileWriter(startupFile) fileWriter.write("") fileWriter.close() File mappingFile = new File("$&#123;project.buildDir&#125;/outputs/mapping/release/mapping.txt") debugStartupFile.eachLine("utf-8") &#123; str, linenumber -&gt; boolean hasProguarded = false mappingFile.eachLine("utf-8") &#123; mapStr, linenumber1 -&gt; String string = mapStr.substring(0, mapStr.indexOf("-&gt;") - 1) string = string.replace('.', '/') string += ".class" if (string.equals(str)) &#123; String strTmp = mapStr.substring(str.length() - 2) strTmp = strTmp.replace('.', '/') strTmp = strTmp.replace(':', '.class') startupFile.append(strTmp + "\n") hasProguarded = true return &#125; &#125; &#125; if (!hasProguarded) &#123; startupFile.append(str + "\n") &#125; &#125; &#125;&#125; 至此，寻找启动类工作基本完成，但不难发现一个问题，那就是build release版本是将会更加耗时，从上面gradle脚本中不难发现，涉及到2层循环，并且mapping.txt文件通常有上万行，这也是这种方法最大的缺陷之一。构建得到APK之后，点击icon，貌似一切正常work！但，但，但，重要的事说三遍，至此并非所有事情都做完了，仍然可能会遗留一些问题！通过以上方法找到的启动依赖类并非100%正确，几千上万个类中遗漏几个毕竟不是小概率事件，解决方法还得多次启动，通过adb logcat获取启动日志，在日志中查找NoClassDefFoundError、Could not find class、Could not find method等warning，有必要的话仍需将这些形成warning的类添加到startup_keep_list_debug.txt文件中，多次启动，直到没有相关的warning，这么做是为了减小未知风险。至此，这种MultiDex实现方法基本也就完成了，后续会寻求其他更好的解决方案，比如动态加载dex方式等等。 MultiDex使用小结以上基本上就是我实现MultiDex的整个过程，中间有多少坑只有实现了才知道！个人认为无必要和绝对把握还是远离它比较好，特别是针对用户量大的App，任何线上ANR/Crash的影响范围可想而知。 提高代码质量应该足以避开MultiDex，毕竟人家微信这么大个App也才只有65428个方法，人家还没超65536呢！ 多次启动(指首次启动)查看启动log是必须的，一来测试MultiDex是否会对首次启动时间产生明显影响，最重要的还是查看启动过程中是否有找不到的类； 通常多次云测也是必须的，毕竟QA能够覆盖到的机型有限，云测也节省了QA工作量。 以上便是个人实现MultiDex的一种方式，不尽完美但却能够解决当下问题，但仍然在寻求最优的解决方法，当你看到这篇文章时，如果你有好的建议或者意见，请不吝赐教！ 相关参考[1] http://developer.android.com/tools/building/multidex.html[2] http://blog.waynell.com/2015/04/19/android-multidex/[3] http://tech.meituan.com/mt-android-auto-split-dex.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一篇文章带你了解Android之Gradle]]></title>
      <url>https://xdrush.github.io/2016/03/30/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Android%E4%B9%8BGradle/</url>
      <content type="text"><![CDATA[1 Groovy &amp; Gradle基础1.1 Groovy这里不作介绍，像写脚本一样写Java，也是运行在JVM上。比较简单，是Gradle基础，当然，也可以用纯Java来写gradle。 1.2 GradleGradle是一个工具，同时它也是一个编程框架。使用这个工具可以完成app的编译打包等工作，当然也可以用它干其他的事情。Gradle相关文档见这里，我们编写所谓的编译脚本，其实就是在用Gradle提供的API。Gradle是一个框架，它提供了很多基本组件：Gradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的task。比如一个Android APK的编译可能包含：Java源码编译task、资源编译task、JNI编译task、lint检查task、打包生成APK的task、签名task等。每个Project具体包含多少个task是有编译脚本指定的插件决定的，这个在后面会讲到。 Gradle作为一个框架，它负责定义流程和规则。而具体的编译工作则是通过插件的方式来完成的。比如编译Java有Java插件，编译Groovy有Groovy插件，编译Android APP有Android APP插件，编译Android Library有Android Library插件等等。 1.2.1 Gradle对象Gradle主要有三种对象，这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：(1) Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。(2) Project对象：每一个build.gradle会转换成一个Project对象。(3) Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。 其中最重要的就是project对象，project包含若干个tasks，在project中，我们要做如下工作： 加载插件 配置插件 设置属性 加载插件加载插件是调用它的apply函数，我们常见的就有以下几个：123apply plugin: 'com.android.library'apply plugin: 'comn.android.application'apply from: "$project.rootDir/build.gradle" // 加载另外一个**.gradle文件，通常定义一些公共的模块 配置插件配置插件这里就不作多说，后文会详细讲到。 设置属性如果是单个脚本，则不需要考虑属性的跨脚本传播，但是Gradle往往包含不止一个build.gradle文件，比如我设置的utils.gradle，settings.gradle。如何在多个脚本中设置属性呢？ Gradle提供了一种名为extra property的方法。extra property是额外属性的意思，在第一次定义该属性的时候需要通过ext前缀来标示它是一个额外的属性。定义好之后，后面的存取就不需要ext前缀了。ext属性支持Project和Gradle对象。即Project和Gradle对象都可以设置ext属性。后文会讲到。 2 Android Gradle简介目前Android基本上都是采用Gradle进行构建，针对大家对gradle用法的一些疑惑，下面将详细剖析gradle在android构建中的用法。 2.1 Android Gradle目录结构首先来看看一个典型的Android工程中gradle的结构： 上图基本就是目前典型的Android结构（Dolphin里面的更为复杂，相对Gradle用法有进一步了解的，请参考Dolphin），万变不离其宗，理解了这些，再复杂的配置都能清晰看懂。 2.2 Top Level GradleTop Level Gradle用于配置所有Module的属性，包括一些公共的方法、公共的依赖项。一般包含3个文件，build.gradle、settings.gradle、gradle.properties。下面来依次了解下每个文件是用来干什么的。 2.2.1 build.gradle文件 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125;/** * 定义外部属性,所有Module中均用这里的配置,避免Project修改时所有Module都要更改. */ext &#123; // Android config androidBuildToolsVersion = '23.0.2' androidMinSdkVersion = 16 androidTargetSdkVersion = 23 androidCompileSdkVersion = 23 androidVersionCode = 1 androidVersionName = '1.0' // libraries config supportVersion = '23.1.1' picasso = '2.5.2' commonDependencies = [ appcompatV7 : "com.android.support:appcompat-v7:$&#123;supportVersion&#125;", design : "com.android.support:design:$&#123;supportVersion&#125;", picasso : "com.squareup.picasso:picasso:$&#123;picasso&#125;" ]&#125; 接下来来具体看看top level构建脚本下每个节点代表什么。 buildscript节点buildscript节点是运行该构建脚本所需要用到的依赖文件，repositories则指定了依赖文件的查找位置。一般而言，这个script block都写在脚本开头，声明这个脚本本身运行所需的依赖。 allprojects设置当前project以及所有sub project中依赖文件的查找路径。 task clean定义一个新的task叫做clean，类型为Delete。Android Plugin内置了clean方法，但是该方法在module中，module中内置的clean方法只会清理module中的文件并删除module中的build目录，但是工程根目录中的build文件没有被删除。因此，这里定义的clean方法删除根目录下的build文件夹。 2.2.2 settings.gradle文件 示例 1include ':app', ':third_party' 说明管理所有sub project，凡是要被编译的子项目，都要写在这里，gradle按照这个配置递归编译子项目。 2.2.3 gradle.properties配置gradle JVM运行的一些参数，MaxHeapSize之类的，本地环境配置。 2.3 Module Level Gradle模块级的脚本描述的是该模块的编译过程，一般而言，Android用到的有两种： Application：apply plugin: ‘com.android.application’，编译结果为apk Library：apply plugin: ‘com.android.library’，编译结果为aar application插件和library插件内容配置差不多，这里分别用讲述以2中形式来分别配置Module的gradle. 2.3.1 application build.gradle代码示例首先来看第一种方式，直接读取top level的build.gradle中属性值，然后再使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101apply plugin: 'com.android.application'/** * 定义外部属性. */ext &#123; app_name = "Gradle Demo"&#125;/** * 配置Android属性,有很多属性可以配置,具体可以参考&#123;@link com.android.build.gradle.BaseExtension&#125; */android &#123; /** * 获取project配置。 */ def globalConfiguration = rootProject.extensions.getByName("ext") compileSdkVersion globalConfiguration.getAt("androidCompileSdkVersion") buildToolsVersion globalConfiguration.getAt("androidBuildToolsVersion") defaultConfig &#123; applicationId "io.xdrush.com.gradledemo" minSdkVersion globalConfiguration.getAt("androidMinSdkVersion") targetSdkVersion globalConfiguration.getAt("androidTargetSdkVersion") versionCode globalConfiguration.getAt("androidVersionCode") versionName globalConfiguration.getAt("androidVersionName") // manifest占位符替换. manifestPlaceholders = [app_name: app_name] &#125; packagingOptions &#123; exclude 'main/AndroidManifest.xml' &#125; signingConfigs &#123; debug &#123; &#125; /** * 配置Release版签名文件. */ release &#123; keyAlias 'm8u' keyPassword 'com.cyou.m8u' storeFile file("key/m8u") storePassword 'com.cyou.m8u' &#125; &#125; /** * type默认会有debug和release,通常在debug中保留默认值,release中开启混淆,并使用签名文件进行签名. */ buildTypes &#123; debug &#123; // 使用默认值. &#125; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release &#125; &#125;&#125;dependencies &#123; /** * 获取project commonDependencies. */ def dependencies = rootProject.ext.commonDependencies compile dependencies.appcompatV7 compile dependencies.design// compile dependencies.picasso /** * 导入libs文件夹下所有的jar文件. */ compile fileTree(dir: 'libs', include: ['*.jar']) /** * 本地aar依赖. */ compile(name: 'trendingsdk-1.1.1', ext: 'aar') /** * 配置依赖Module. */ compile project(':third_party')&#125;/** * 配置本地libs为依赖查找源,当需要导入本地.aar文件时需要这个. */repositories &#123; flatDir &#123; dirs 'libs' &#125;&#125; 2.3.2 library build.gradle代码示例第二种读取方式则更为简单，直接导入top level的build.gradle，随后可以直接读取其中的属性值：123456789101112131415161718192021222324252627apply plugin: 'com.android.library'apply from: "$project.rootDir/build.gradle"android &#123; compileSdkVersion androidCompileSdkVersion buildToolsVersion androidBuildToolsVersion defaultConfig &#123; minSdkVersion androidMinSdkVersion targetSdkVersion androidTargetSdkVersion versionCode androidVersionCode versionName androidVersionName &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile commonDependencies.appcompatV7 compile fileTree(dir: 'libs', include: ['*.jar'])&#125; 推荐使用这种方式来读取ext值。 3 Gradle之task详解以上还只是了解gradle的基本配置，而gradle构建最最核心的部分是各个插件提供的task，每个task独自执行自己的任务，将构建一步步拆分。 3.1 task简介task是gradle中的一种数据结构，它代表一些要被执行的工作，是构建任务的最基本执行单元，不同的插件有不同的task，每一个task都需要和一个project相关联。 可以看到，上面属于library插件的third_party的task和属于application插件的app的task是不相同的。需要强调的一点是，org.gradle.api.Project这个类是build.gradle构建脚本同gradle交互的主要接口，几乎所有方法都在这个类中能找得到。 3.2 自定义taskProject提供了task函数方便我们创建task，先来看看Project中是如何定义task的：1234567891011121314/** * &lt;p&gt;Creates a &#123;@link Task&#125; with the given name and adds it to this project. Calling this method is equivalent to * calling &#123;@link #task(java.util.Map, String)&#125; with an empty options map.&lt;/p&gt; * * &lt;p&gt;After the task is added to the project, it is made available as a property of the project, so that you can * reference the task by name in your build file. See &lt;a href="#properties"&gt;here&lt;/a&gt; for more details&lt;/p&gt; * * &lt;p&gt;If a task with the given name already exists in this project, an exception is thrown.&lt;/p&gt; * * @param name The name of the task to be created * @return The newly created task object * @throws InvalidUserDataException If a task with the given name already exists in this project. */ Task task(String name) throws InvalidUserDataException; 简要描述就是，一旦task被创建，那么它会被当做project的一个属性，由gradle自动执行，Project有几个关于task的重载版本，功能大致一样。我们在Android中一般看的task是形如下面的格式：12345task myTask // 创建一个名为myTask的tasktask myTask &#123; configure closure &#125; // 重载版本，执行一段闭包task myType &lt;&lt; &#123; task action &#125; // 重载版本task myTask(type: SomeType) // 创建task，并指定type，关于type，后面会讲到task myTask(type: SomeType) &#123; configure closure &#125; “&lt;&lt;”符号表示的task.doLast，”&gt;&gt;”表示task.doFirst，后面的闭包表示task执行完之后/之前，再执行这段闭包。 type:someType又是什么意思呢？其实就是告诉gradle，这个新建的task是从哪个基类task派生而来的。Gradle本身提供了一些通用的task，比如Copy，Delete等等。1234567public class Copy extends AbstractCopyTask &#123; ...&#125;public class Delete extends ConventionTask &#123; ...&#125; 以一个例子来看看task的创建：1234task clean(type: Delete) &#123; println "clean task executing." delete rootProject.buildDir&#125; 这个例子在Top level的build.gradle中创建一个名为clean，type为delete的task，先来看看top level中tasks有什么变化： 可以看到，task一旦创建即被加入到project的task序列中，成为project的一个属性。 这个task具体做什么呢？task里面的这段闭包已经说明了，就是删除根目录下的build文件夹。task里面可以做很多事情，具体下面会介绍到。 3.3 task扩展本小节将在新建task基础上做些扩展，来展示task是如何做更多事情的，相信大家看过之后，不再畏惧gradle，即使不会写但也至少能看得懂。 Android构建给我们已经提供了很多task（可以参考这里），这里结合Android中multidex实现来讲讲task的更多用法：1234567891011121314151617181920tasks.whenTaskAdded &#123; task -&gt; // 遍历所有的task， "-&gt;"就是迭代器的意思 // 如果是create&#123;Debug/Release&#125;MainDexClassList，则执行以下闭包action. if (task.name.startsWith("create") &amp;&amp; task.name.endsWith("MainDexClassList")) &#123; task.doLast &#123; // 该task执行完成之后，再执行以下action，替换分包内容. File tempFile File keepFile if (task.name.contains("Debug")) &#123; tempFile = new File("$project.rootDir/MyProject/keep_in_maindexlist_debug.txt") keepFile = new File("$&#123;project.buildDir&#125;/intermediates/debug/maindexlist.txt") &#125; else if (task.name.contains("Release")) &#123; tempFile = new File("project.rootDir/MyProject/keep_in_maindexlist_release.txt") keepFile = new File("&#123;project.buildDir&#125;/intermediates/release/maindexlist.txt") &#125; tempFile.eachLine("utf-8") &#123; str, linenumber -&gt; keepFile.append(str + "\n") &#125; &#125; &#125;&#125; 上述代码功能大概意思就是江create{Debug/Release}MainDexClassList这个task（对这个不熟的可以参考这里）形成的maindexkeep文件给替换掉。下面来具体分析这个例子： (1) 首先这个在top level的build.gradle中，因为是要干预整个工程的分包，而不是针对某个module的；(2) 这里的意思是将所有的task添加到project中，闭包有一个输入参数：task，这里”task -&gt;”相当于迭代器，闭包内有一个默认参数it，代表的就是tasks，这里没有用到。(3) 获取指定的task，可以根据getByName方法获取指定的task。12345tasks.getByName("assembleRelease") &#123; it.doLast &#123; println "assemble release done." &#125;&#125; 除了上面提到的tasks.whenTaskAdded之外，我们还常见到project.afterEvaluated，它的意思是gradke解析完所有的task之后，并且在具体task开始执行之前，我们可以做的事情。 Android每个project都提供了tasks、project、gradle等内置对象供我们来访问，利用这些对象我们就可以对每个task进行hook，进而能够充分干预整个构建过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读书笔记之《中国历代政治得失》]]></title>
      <url>https://xdrush.github.io/2016/03/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1%E3%80%8B/</url>
      <content type="text"><![CDATA[这本书是钱穆的专题演讲合集，分别就中国汉、唐、宋、明、清五代的政府组织、百官职权、考试监察、财政赋税、兵役义务等种种政治制度做了提要钩玄的概观和比照，高屋建瓴，气势恢弘。 说来也巧，这本书是某当一次拼单实在是差十几块钱偶然看到的，定价24打完折十几块钱在现在动辄几十块钱的图书市场实在是良心作品。最初知道钱穆，是宇同学向我推荐，那时正想着看些历史书，他就索性给我推荐了黄仁宇和钱穆这俩人，后也断断续续度过若干这两位作品，观点独到，自成一家之言，可读性很强。 总结从两千年的历史中，我们可以对以往传统政治，找出几条大趋势。 第一：中央政府有逐步集权的倾向。这丛某一方面讲是好的，一个国家该要有一个凝固的中央。政治进步，政权自然集中，任何国家都走这条路。开始是封建，四分五裂，满满地就统一集中。 第二：可以说中国历史上的传统政治，已造成了社会各阶层一天天趋向于平等。 第三：长治久安，是人人希望的，可是在这种情形下的知识分子，至多也只能维持上三代（注：笔者很小时候便常听老一辈说富不过三代，大抵如此）。对于这点，倒觉得与现代社会有些偏差，不敢苟同。 第四：是中国的政治制度，相沿日久，一天天地繁密化。一个制度出了毛病，再订一个制度来防制它，于是有些却变成了病上加病。制度愈繁密，人才愈束缚。 至于文中详细对于各个朝代政治制度的对比，这里不作详述，书中有详述。 是为2017年5月读书笔记，2017年6月读《清教徒的礼物》。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Retrofit下载文件]]></title>
      <url>https://xdrush.github.io/2016/03/15/%E4%BD%BF%E7%94%A8Retrofit%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      <content type="text"><![CDATA[说明这里不会对Retrofit进行介绍，欲了解Retrofit的请自行google之。这里只关注如何用Retrofit从服务器下载文件。 Retrofit下载普通文件这里普通文件是指比较小的文件，比如图片、文本等。如果你厌倦了HttpRequest下载文件的方式，相信你看了下文一定会喜欢上Retrofit的。这里我以Android中下载网络图片来设置ImageView为例： 定义Retrofit接口123456789101112131415private final static String mBaseUrl = "http://opsen-static.dolphin-browser.com"; private final static String mFileUrl = "/resources/icon/provision_services/1443166704.png";interface DownloadServiceApi &#123; @GET(mFileUrl) Call&lt;ResponseBody&gt; getSmallSizeFile();&#125;private DownloadServiceApi getDownloadServiceApi() &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(mBaseUrl) .build(); return retrofit.create(DownloadServiceApi.class);&#125; 异步下载图片并设置ImageView1234567891011121314151617181920212223242526272829303132333435363738// 网络操作另开线程来做.new Thread(new Runnable() &#123; @Override public void run() &#123; downloadFile(); &#125;&#125;).start();private void downloadSmallFile() &#123; DownloadServiceApi downloadServiceApi = getDownloadServiceApi(); final Call&lt;ResponseBody&gt; call = downloadServiceApi.getSmallSizeFile(); try &#123; // 同步下载文件 Response&lt;ResponseBody&gt; response = call.execute(); if (response.isSuccessful()) &#123; ResponseBody responseBody = response.body(); byte date[] = responseBody.bytes(); final Bitmap bitmap = BitmpaFactory.decodeByteArray(data, 0, date.length); // 设置ImageView，注意要在UI线程中做. runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mImageView.setImageBitmap(bitmap); &#125; &#125;); &#125; &#125; catch (Exception e) &#123; Log.e(TAG, e.toString()); &#125;&#125;new Thread(new Runnable() &#123; @Override public void run() &#123; downloadSmallFile(); &#125; &#125;).start(); 有一点需要注意，那就是必须以ResponseBody作为返回类型，Retrofit会试图解析并转换它，所以不能使用任何其他返回类型，否则下载的文件毫无意义。 文件下载下来了，要保存在本地也就是很简单的事了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private boolean writeResponseBodyToDisk(ResponseBody responseBody) &#123; try &#123; File saveFile = new File(getExternalFilesDir(null) + File.separator + "MyFile.apk"); InputStream inputStream = null; OutputStream outputStream = null; try &#123; byte[] fileReader = new byte[2000]; inputStream = responseBody.byteStream(); outputStream = new FileOutputStream(saveFile); while (true) &#123; int read = inputStream.read(fileReader); if (-1 == read) &#123; break; &#125; outputStream.write(fileReader, 0, read); &#125; outputStream.flush(); // 提示下载成功. runOnUiThread(new Runnable() &#123; @Override public void run() &#123; showTips("Save to local storage finished!"); &#125; &#125;); return true; &#125; catch (Exception e) &#123; return false; &#125; finally &#123; if (null != inputStream) &#123; inputStream.close(); &#125; if (null != outputStream) &#123; outputStream.close(); &#125; &#125; &#125; catch (Exception e) &#123; Logger.e(e.toString()); &#125; return false; &#125; private void showTips(String tips) &#123; Toast.makeText(MainActivity.this, tips, Toast.LENGTH_SHOW).show(); &#125; Retrofit下载大文件默认情况下，Retrofit在处理结果之前会将这个ResponseBody读进内存，这在普通文件的Response上表现还好，但如果是一个视频等大文件，就极有可能导致OutOfMemory。 好在Retrofit为了避免这个问题，引入了Streaming注解！它意味着立即传递字节码而不是一下子传递整个文件然后缓存在内存中。来看下面的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface DownloadServiceApi &#123; @GET(mFileUrl) Call&lt;ResponseBody&gt; getSmallSizeFile(); @Streaming @GET Call&lt;ResponseBody&gt; getBigSizeFile(@Url String fileUrl);&#125;private void downloadBigFile() &#123; String fileUrl = "........"; DownloadServiceApi downloadServiceApi = getDownloadServiceApi(); final Call&lt;ResponseBody&gt; call = downloadFileApi.getBigSizeFile(fileUrl); // 异步下载文件. call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, final Response&lt;ResponseBody&gt; response) &#123; if (response.isSuccessful()) &#123; showTips("download Successful and start writing file to local storage."); new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... voids) &#123; boolean writeResult = writeResponseBodyToDisk(response.body()); return null; &#125; &#125;.execute(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; showTips("download failed!"); &#125; &#125;);&#125; new Thread(new Runnable() &#123; @Override public void run() &#123; downloadBigFile(); &#125; &#125;).start(); 这里也有一点需要特别注意：onResponse()、onFailure()方法都是在主线程中调用的，因此最好使用AsyncTask()来处理保存文件到本地的操作，不然会阻塞UI线程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式跟风作之观察者模式]]></title>
      <url>https://xdrush.github.io/2016/03/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="text"><![CDATA[1 观察者模式简介观察者模式定义了一种一对多的依赖关系，让多个Observer对象同时监听某个Observable（被观察者）对象。当Observable对象在状态发生变化时，会通知所有（或者部分）Observers，让这些observers能够自动更新自己。 2 观察者模式的组成2.1 抽象Observable角色把所有对观察者对象的引用保存在一个集合中，每个抽象Observable角色都可以有任意数量的Observer。抽象Observable提供一个接口，可以增加、删除Observer。一般用一个抽象类和接口来实现。 2.2 抽象Observer角色为所有具体的Observer定义一个接口，在得到Observable的通知时更新自己。 2.3 具体Observable角色在具体Observable内部状态改变时，给所有注册过的Observers发出通知。具体Observable通常是抽象Observable的一个子类实现。 2.4 具体Observer角色该角色实现抽象Observer所要求的接口，以便使自己的状态与Observable的状态相协调。通常用一个子类来实现。如果需要，具体Observer角色可以保存一个指向具体Observable角色的引用。 3 观察者模式实现3.1 抽象Observer实现123456/** * 抽象Observer角色 */public interface Watcher &#123; void update(String str);&#125; 3.2 抽象Observable实现1234567891011/** * 抽象Observable角色. */public interface Watched &#123; void addWatcher(Watcher watcher); void removeWatcher(Watcher watcher); void notifyWatchers(String str);&#125; 3.3 具体Observer实现12345678910/** * 具体的Observer实现 */public class ConcreteWatcher implements Watcher &#123; @Override public void update(String str) &#123; System.out.println(str); &#125;&#125; 3.4 具体Observable实现123456789101112131415161718192021222324252627282930313233343536/** * 具体Observable实现 */public class ConcreteWatched implements Watched &#123; private List&lt;Watcher&gt; mWatcherList = new ArrayList&lt;&gt;(); @Override public void addWatcher(Watcher watcher) &#123; if (null == watcher) &#123; return; &#125; mWatcherList.add(watcher); &#125; @Override public void removeWatcher(Watcher watcher) &#123; if (null == watcher) &#123; return; &#125; if (0 == mWatcherList.size()) &#123; return; &#125; mWatcherList.remove(watcher); &#125; @Override public void notifyWatchers(String str) &#123; for (Watcher watcher : mWatcherList) &#123; watcher.update(str); &#125; &#125;&#125; 3.5 测试用例12345678910111213141516public class ObservableTest &#123; public static void main(String[] args) &#123; Watched employees = new ConcreteWatched(); Watcher employee1 = new ConcreteWatcher(); Watcher employee2 = new ConcreteWatcher(); Watcher employee3 = new ConcreteWatcher(); employees.addWatcher(employee1); employees.addWatcher(employee2); employees.addWatcher(employee3); employees.notifyWatchers("xdrush"); &#125;&#125; 4 Java中的观察者模式4.1 Java中的Observer和ObservableJava在java.util.*;包中提供了现成的观察者模式实现，具体的两个类分别是Observer和Observable；这两个类充当上节中的抽象Observer和抽象Observable功能。 4.2 使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 首先定义SimpleObserverpublic class SimpleObserver implements Observer &#123; public SimpleObserver(SimpleObservable observable) &#123; observable.addObserver(this); &#125; @Override public void update(Observable observable, Object object) &#123; if (observable instanceof SimpleObservable) &#123; SimpleObservable simpleObservable = (SimpleObservable) observable; System.out.println("data has changed to -&gt; " + simpleObservable.getData()); &#125; &#125;&#125;// 定义SimpleObservablepublic class SimpleObservable extends Observable &#123; private int mData = 0; public void setData(int data) &#123; if (this.mData == data) &#123; return; &#125; this.mData = data; setChanged(); notifyObservers(); &#125; public int getData() &#123; return mData; &#125;&#125;// 简单测试public class ObservableTest &#123; public static void main(String[] args) &#123; SimpleObservable observable = new SimpleObservable(); SimpleObserver observer1 = new SimpleObserver(observable); SimpleObserver observer2 = new SimpleObserver(observable); SimpleObserver observer3 = new SimpleObserver(observable); observable.setData(5); observable.setData(6); observable.setData(6); &#125;&#125; 4.3 ObserverObserver接口只提供了一个方法update()：123public interface Observer &#123; void update(Observable observable, Object object);&#125; 4.4 ObservableObservable提供了几个关键的接口：(1) setChanged()用来设置一个内部标志位注明数据发生了变化；只有setChanged()方法被调用，notifyObservers()方法才会被正确的执行；这在notifyObservers()方法源码中有具体的体现； (2) notifyObservers()/notifyObservers(Object object)通知所有的Observers数据发生了变化，这时所有的Observer会自动调用复写好的update(Observable, Object)方法来做一些处理。其中Object参数可以用来作为ID，然后在所有的Observer中作判断，每个Observer判断只有接收到的参数ID属于自己的才做一些处理。 其他的方法可直接看源码，比较简单，易于理解。 4.5 使用注意事项在Observer对象被销毁前一定要用deleteObserver将其从列表中删除，否则因为在Observable中还存在对象的引用，导致Observer不会被垃圾收集，曹成内存泄漏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式跟风作之装饰者模式]]></title>
      <url>https://xdrush.github.io/2016/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B7%9F%E9%A3%8E%E4%BD%9C%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="text"><![CDATA[1. 装饰者模式概述1.1 定义装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。 1.2 使用场景在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；类已定义为不能被继承（譬如final类）。 1.3 装饰者模式构成Component（抽象构件）它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 ConcreteComponent（具体构件）它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。 Decorator（抽象装饰类）它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 ConcreteDecorator（具体装饰类）它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 2. 使用示例本例模拟咖啡店点单系统：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * This is the abstract component（抽象构件）. * * Created by xdrush on 2017/1/25. */public abstract class Beverage &#123; String mDescription = "Unknown Beverage"; public String getDescription() &#123; return mDescription; &#125; public abstract double cost();&#125;/** * This is Decorator（抽象装饰类）. * The decorator should be abstract. * * Created by xdrush on 2017/1/25. */public abstract class CondimentDecorator extends Beverage &#123; public abstract String getDescription();&#125;/** * This is concrete object to be decorated（具体构件，被装饰者）. * * Created by xdrush on 2017/1/25. */public class Espresso extends Beverage &#123; public Espresso() &#123; mDescription = Espresso.class.getSimpleName(); &#125; @Override public double cost() &#123; return 1.29; &#125;&#125;/** * This is the concrete decorator（具体装饰者）. * * Created by xdrush on 2017/1/25. */public class Mocha extends CondimentDecorator &#123; Beverage mBeverage; public Mocha(Beverage beverage) &#123; mBeverage = beverage; &#125; public String getDescription() &#123; return mBeverage.getDescription() + ", Mocha"; &#125; @Override public double cost() &#123; return 0.20 + mBeverage.cost(); &#125;&#125; 3. 总结3.1 装饰模式优点 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。 可以通过一种动态的方式在运行时选择不同的具体装饰类，从而实现不同的行为。 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。 3.2 装饰模式缺点 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊聊RxJava & RxAndroid]]></title>
      <url>https://xdrush.github.io/2016/02/10/%E8%81%8A%E8%81%8ARxJava%20&%20RxAndroid/</url>
      <content type="text"><![CDATA[一、RxJava简介What is Rx?Rx，即Reactive Extensions，是一种编程模型，目标是提供一致的编程接口，有助于更方便的处理异步数据流。响应式编程主要由Observable、Operator和Subscriber组成，一般来讲，响应式编程的信息流如下：1Observable -&gt; Operator1 -&gt; Operator2 -&gt; ... -&gt; Subscriber 也就是Observable是事件的生产者，Subscriber是事件最终的消费者，并且，Subscriber通常是在主线程中执行，只负责对事件进行响应，这就要求其处理的事情越少越简单越好，而对事件的处理尽量交由Observable和Operator。 RxJava是什么东东？1RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences. 本质上来讲，RxJava就是一个封装异步操作的库！ RxJava核心概念RxJava最核心的2个概念就是：Observable(被观察者、事件源)和Observer(一般用Subscriber，观察者)。Observable产生一系列事件(触摸事件，网络请求，文件读写)，并将这些事件发送出去，Observer处理这些事件所产生的结果。 一个Observable可以发出多个事件，直到结束或者出错，每发出一个事件，就会调用它的Subscriber的onNext()方法，然后再调用onComplete()或者onError()方法作为结束。一个Observable如果没有任何Subscriber，则不会发出任何事件(可简单理解为一段不会执行的代码)，也就是Observable和Subscriber必须成对使用。一个Observable可以同时被多个Subscriber订阅。 举一个最简单的例子来理解Observable和Subscriber，Android中通常这么用： 123view.setOnClickListener(new View.OnClickListener() &#123; // ...&#125;); 这里我们可以简单的理解view就是Observable，OnClickListener就是Subscriber，view和OlClickListener通过setOnClickListener()方法进行绑定，如下图所示： RxJava基本使用步骤举一个简单的例子来示例RxJava基本使用步骤：向屏幕发送一个字符串，并显示出来： 创建Observable123456789101112// String为输入Observable&lt;String&gt; observable = Observable.create(new OnSubscribee&lt;String&gt;() &#123; @Override public void call(Subscribe&lt;? super String&gt; subscriber) &#123; // 产生事件 // TODO: ...... // 事件完成的结果回调 subscriber.onNext("Hello World."); subscripber.onCompleted(); &#125;) 这里定义的Observable仅仅发出了一个”Hello World”字符串，然后就结束了。 创建Subscriber1234567891011121314151617Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt; &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String string) &#123; System.out.println(string); &#125;&#125; 创建一个Subscriber来处理Observable发出的字符串这个事件，其中onNext()，onCompleted()，onError()是回调方法供Observable调用。 Observable和Subscriber的绑定1Subscription subscription = observable.subscribe(subscriber); 最后将创建的observable和subscriber绑定，subscribe()会返回一个Subscription对象（后文会说明这个对象的作用）。以上便是RxJava使用的“三步走”过程，简单明了。 为什么要用RxJava？上面给出的打印字符串的例子，如果不用RxJava可能一两行就能搞定，那为什么还要如此大费周章的使用RxJava呢？的确，大多数场景下，RxJava是画蛇添足，但别忘了开头所说，RxJava是为异步而生！ 也许Handler，new Thread，AsyncTask…等等已经在脑子里根深蒂固了，不错，这些已经让异步实现更简洁了，但，RxJava会让异步变得更！简！！单！！！并且，随着程序逻辑变得越来越复杂，RxJava依然能够保持代码的简洁性和可读性。注意，这里所说的简单，并不是说代码量会更少，而是指逻辑、结构会更加简单明了。 同样，举一个简单例子：给定一个图片url，设置ImageView【注：这里不考虑Picasso、Fresco等图片库】， 先来看看new Thread()是怎么做123456789101112new Thread(new Runnable() &#123; @Override public void run() &#123; mBitmap = downloadBitmap(url); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;); &#125;&#125;).start(); AsyncTask实现的代码量不会比这更少。 再来看看RxJava是怎么实现的123456789101112131415Observable.just(url) .map(new Func1&lt;String, Bitmap&gt;) &#123; @Override public Bitmap call(String url) &#123; return downloadBitmap(url); &#125; &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;); 暂且不要管上面每行代码是什么意思，看完下文之后自然会明白。上例也许并不恰当，粗看RxJava行数更多，的确，但RxJava以这种链式结构来实现异步，不至于将将代码搞得到处都是。试想，在此基础上作一点扩展，给定10个url来设置一组ImageView呢？来看看RxJava怎么做：1234567891011121314151617String[] iconUrls = new String[]&#123;...&#125;;// ...Observable.from(iconUrls) .map(new Func1&lt;String, Bitmap&gt;) &#123; @Override public Bitmap call(String url) &#123; return downloadBitmap(url); &#125; &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; mImageView[i].setImageBitmap(mBitmap); &#125; &#125;); 对的，就是这么简单，只需改动一两个地方，就可以很完美的应对扩展。这也就是上面所说的，异步操作越复杂，越能体现出RxJava的优势！ 代码简化前面举了打印字符的例子，那个例子中代码过于复杂，我们关注的其实也就是一个回调方法而已，那么，能将这些代码精简些吗？实际上，RxJava内置了很多便捷的函数方便我们来简化代码。下面列出一些常用的简化版方法： Observable简化Single Single是Observable的一个精简版，其功能基本与Observable一样；Observable在某些场景下过于重量级，需要关注其回调方法的onNext()/onComplete()/onError()，但实际上大部分场合只需关注onNext()即可，Single正是这么干的。1234567891011Single.just(T t) .subscribe(new SingleSubscriber&lt;T&gt; &#123; @Override public void onSuccess(T t) &#123; // ... &#125; @Override void onError(Throwable error) &#123; &#125; &#125;); Observable.just(T…)Observable.just()用于创建只发出一个事件就结束的Observable对象：1Observable&lt;String&gt; observable = Observable.just("Hello World"); 如果传入的是一个数据，则将传入的参数依次发送出去。12345Observable observable = Observable.just("hello", "world");// 将会依次调用：// onNext("hello");// onNext("world");// onComplete(); Observable.from(T[])将传入的数组或者Iterator拆分成具体对象，然后依次发送出去。12String[] strings = &#123;"hello", "world"&#125;;Observable observable = Observable.from(strings); 本质上同上面的just()差不多，归根到底和create()是等价的。 Subscribe的简化Subscribe有3个方法，其实大部分时候我们只需要关心onNext()方法而不用在意onComplete()和onError()(上面的例子中不难看出这两个方法占用了不少代码体积)，这时候我们可以使用Action类(Action类无返回值)，RxJava提供了多个参数的Action类，Action1, Action2, Action3, Action4,…,分别表示能处理多少个结果。123456Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; // TODO: do something... &#125;&#125; Observable.subscribe()方法有个重载的版本，接受3个Action1类型的参数，分别对应其onNext()，onCompleted()，OnError()方法：1Observable.subscribe(onNextAction, onErrorAction, onCompleteAction); 如果不关心onError和onCompleted，则只需一个参数即可：1Observable.subscribe(onNextAction); 鉴于此，上例中的代码最终可以简化为：1234567Observable.just("Hello World") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; // TODO: do something... &#125; &#125;); Function简化RxJava中提供了类似上述Action类的简化，同时也提供了包装多个参数并且有返回值的类Func，123public interface Func1&lt;T, R&gt; extends Function &#123; R call(T t);&#125; 以上便是Func1的源码，T为输入参数，R为返回值；同理，Func2接收两个输入一个返回，以此类推。Func在中间变换时非常重要。 二、RxJava操作符Why Operator？对Rx来说，Observable和Subscriber仅仅是个开始，它们本身不过是标准观察者模式的一些轻量级扩展，目的是为了更好的处理事件序列。但Rx真正强大的地方在于它的操作符！ 操作符是为了解决对Observable对象的变换问题，其目的在于对Observable发出的事件在最终的Subscriber得到事件结果之前对Observable发出的事件进行修改。变换不仅能处理单个事件，也能同时处理整个序列中的事件，将这些事件转换成不同的事件。 为什么需要操作符？根据响应式函数编程的概念，Subscriber更应该做的事情是“响应”，响应Observable发出的事件，仅此而已！Observable做的事情仅仅是产生事件，事件产生了就再也不关我事！那么问题来了，如果在事件处理完成之前，想对事件做些特别的处理呢？(这种需求大多数场景下应该都会有的吧)。RxJava中的操作符正是为此而产生的！RxJava的强大和精髓就在于其提供了丰富的操作符。并且，Rx操作符拥有简明的异步操作方式，避免了异步系统中的嵌套回调的回调陷阱问题。下面着重介绍几个常用的操作符： map操作符map操作符对事件对象直接变化，是RxJava中最常用的操作符。回到前面根据url设置ImageView的例子：123456789101112131415Observable.just(url) .map(new Func1&lt;String, Bitmap&gt;) &#123; @Override public Bitmap call(String url) &#123; return downloadBitmap(url); &#125; &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;); 上例中，map()操作符将String对象转换成了一个Bitmap对象后返回，经过map()操作符后，事件的类型也就由String转换为了Bitmap类型。map()是RxJava中最常见的变换，但RxJava提供的变换远不止于此，RxJava还可以对整个事件队列进行变换。 flatMap()操作符flatMap()操作符比较难理解，为了更好的说明flatMap()原理及如何使用好它，先来看一个简单的例子：打印一组学生中每个学生的所有课程。123456789101112131415161718Student[] students = &#123;...&#125;;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; System.out.println(course.getName()); &#125; // ... 忽略onComplete()和onError()&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); 从上面的代码中看，flatMap()和map()有一个相同点：把传入的参数经过转换之后返回一个对象，但map()返回的是普通类型的对象，而flatMap()返回的则是Observable对象，并将这个Observable对象激活，藉由这个Observable对象再将一系列事件发送出去。对于分组网络请求使用flatMap()最好不过了。 subscribeOn操作符用于指定订阅事件所在的线程，也就是异步任务执行的线程，下文详细讲解。 observeOn操作符指定回调所在的线程，常见的就是主线程，下文详细讲解。 RxJava还提供了很多其他的操作符，有兴趣可以查阅相关文档。 三、RxJava中的线程调度既然RxJava处理的是异步事件，那么涉及到线程的调度问题是必然的。RxJava强大的另外一点就是其提供了非常非常非常简便的线程操作！ 默认情况下，如果不指定Observable和Subscriber所在的线程，则所有操作默认与subscribe()所在的线程保持一致，即：在哪个线程中调用subscribe()，就在那个线程中生产事件，同时也就意味着在哪个线程中消费事件。如果需要控制操作所在的线程，这时Scheduler就派上了用场。 RxJava中的几个SchedulerRxJava本身已经内置了几个常用的Scheduler，绝大多数场景下，这些Scheduler已经够用了，这些Scheduler主要有： Scheduler.immediate() 不指定线程，直接在当前线程中执行，这也是默认的Scheduler。 Scheduler.newThread() 开启新的线程，并且在新线程中执行相关操作。 Scheduler.io() I/O操作相关的Scheduler，当有涉及到文件读写、数据库操作、网络操作等时，强烈建议制定这些操作在IO线程中执行，io()线程内部实现是一个无数量上限的线程池，这时不需要开启新线程，直接重用空闲的线程，因此io()比newThread()具有更高的效率。 Scheduler.computation() 计算所使用的线程，主要用于执行CPU密集型的计算操作，比如图形计算等。这个Scheduler拥有固定的线程池，大小为CPU核数。 Scheduler.from(Executor) 使用指定的Executor来作为Scheduler，Executor本质上也是使用了线程池机制，其效率由于new Thread。 Scheduler.trampoline() 在当前线程中的工作放入到队列中排队，并以此执行队列中的事件。 Scheduler.test() 用于测试，支持单元测试的高级事件。 AndroidSchedulers.mainThread() 针对Android引入的一个特殊Scheduler，即Android主线程。 RxJava中Scheduler的使用没什么好说的，结合上面所说的observeOn()和subscribeOn操作符，直接上例子：123456789Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定subscribe()发生在IO线程中 .observeOn(AndroidSchedulers.mainThread()) // 指定Subscribe的回调在主线程中进行 .subscribe(new Action1&lt;Integer&gt; &#123; @Override public void call(Integer number) &#123; Log.d(TAG, String.valueOf(number)); &#125; &#125;); 上例中，subscribeOn(Schedulers.io())指定事件的产生实在IO线程中发生，observeOn(Schedulers.mainThread())则指定回调发生在主线中，这种方式对MVP模型非常适用。事实上，RxJava可以指定中间任意一个Operator所在的线程，线程之间的切换非常非常方便！ Scheduler原理不难发现，RxJava变换的本质都是对事件序列进行处理然后再发送出去，再来看看几个典型的变换源码：123456789// map()实现public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) &#123; return lift(new OperatorMap&lt;T, R&gt;(func));&#125;// isEmpty()实现public final Observable&lt;Boolean&gt; isEmpty() &#123; return lift((OperatorAny&lt;T&gt;) HolderAnyForEmpty.INSTANCE);&#125; 进一步阅读源码我们不难发现，基本上所有的变换都是基于lift(Operator)实现的。 可能存在的内存泄漏问题每个Observable和Subscriber绑定时就会生成一个Subscription对象，一个Subscription代表Observable和Subscriber之间的连接。当在多线程场景下，有时Activity的onDestroy()执行之后线程才结束（有可能该线程永远都不会结束），那么这是就有可能出现内存泄漏或者其他异常信息，这一点值得引起注意。12345678910111213141516171819202122232425// subscribe源码摘录public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) &#123; if (onNext == null) &#123; throw new IllegalArgumentException("onNext can not be null"); &#125; return subscribe(new Subscriber&lt;T&gt;() &#123; @Override public final void onCompleted() &#123; // do nothing &#125; @Override public final void onError(Throwable e) &#123; throw new OnErrorNotImplementedException(e); &#125; @Override public final void onNext(T args) &#123; onNext.call(args); &#125; &#125;); &#125; Subscription正是避免这种问题的关键，通过调用unsubscribe()方法，通知Observable其所发送的事件不会再被Subscriber接收，Observble也就不会继续发送事件，这就避免了上述问题。123456789@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (null != mSubscription &amp;&amp; !mSubscription.isUnsubscribed()) &#123; // 解除Observable和Subscriber之间的绑定 mSubscription.unsubscribe(); &#125;&#125; 需要注意的是，如果有多组Observable和Subscriber，则每组都需做这个操作，RxJava提供了CompositeSubscription这个类用来集合多组订阅，销毁Activity时，清除CompositeSubscription即可。12345678private final CompositeSubscription mCompositeSubscription = new CompositeSubscription();// ...mCompositeSubscription.add(subscription);@Overrideprotected void onDestroy() &#123; mCompositeSubscription.clear();&#125; 四、RxAndroidRxAndroid是RxJava针对Android的扩展，其目的主要是简化异步数据处理，RxJava的引入为在Android中灵活的使用函数式响应编程提供便利，并且Android的线程机制也使得RxJava能够完美的应用在Android开发中。 除了上面那个根据url设置ImageView这个例子之外（如其说是个例子，倒不如说提供的是一种在Android中处理异步任务的思想），RxJava还为Android提供了几个方便的API。 RxAndroid相关APIHandlerScheduler除了上面所讲的AndroidSchedulers之外，RxJava还提供了HandlerScheduler，一个用来指定Handler的Scheduler。1234private Handler mHandler = new Handler(getMainLooper());// ...subscribeOn(HandlerScheduler.from(mHandler)) // 指定发出事件所在的子线程// ... 这个api方便定制事件所在的子线程。 与Retrofit相结合对Retrofie，目前我们用到最多的还是Callback接口，事实上Retrofit本身其实已经提供了Observable形式的接口，举一个从服务器拉取网站列表的例子：先来看Callback形式：1234567891011@Get("/list_url")public void getWebsiteList(@QueryMap Map&lt;String, String&gt;, Callback&lt;WebsiteStruct&gt; callback);// ...getWebsiteList(queryMap, new Callback&lt;WebsiteStruct&gt; &#123; @Override public void onResponse(...) &#123; // ... &#125; // ... onFailure()&#125;); 再来看RxJava形式：12345678910111213@GET("/list_url")public Observable&lt;WebsiteStruct&gt; getWebsiteList(@Query Map&lt;String, String&gt;);// ...getWebsiteList(queryMap) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;WebsiteStruce&gt;() &#123; @Override public void onNext(WebsiteStruce websiteStruce) &#123; // ... &#125; // ... &#125;); 对比发现，其实Callback形式和RxJava形式差不多。但，如果改动一下需求：获取的是一些视频文件的url，要求将这些视频下载下来保存到本地呢？可能你已经凌乱了，这用Retrofit怎么搞啊？嵌套Callback可能是条路，你不妨试试看！反正我是已经凌乱了！但是，我知道，RxJava可以很容易的写出来：1234567891011121314151617181920212223getWebsiteList(queryMap) .flatMap(new Func1&lt;WebsiteStruct, Observable&lt;String&gt; &gt; &#123; @Override public Observable&lt;String&gt; call(WebsiteStruct websiteStruct) &#123; return Observable.from(websietStruct.getData()); &#125; &#125;) .map(new Func1&lt;String, String&gt; &#123; @Override public String call(String url) &#123; File file = downloadFile(url); saveFileToLocal(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;String&gt; &#123; // ... @Override public void onNext(String string) &#123; Toast.makeText(...string...); &#125; &#125;) See？奏是如此简单！ 五、总结So，上面讲了这么多，希望能够带你入门RxJava和RxAndroid，更多用法不妨去看下源码；如果你已入门，那么，滚蛋吧AsyncTask，忘掉该死new Thread，Callback？再见！！ 其他的用法目前暂未知，后续学到了或者用到了，再补充！ 参考[1] https://github.com/ReactiveX/RxJava[2] https://github.com/ReactiveX/rxjava/wiki[3] ReactiveX/RxJava文档中文版[4] 给Android开发者的RxJava详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从源码角度聊聊View的工作原理]]></title>
      <url>https://xdrush.github.io/2016/01/25/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E8%81%8A%E8%81%8AView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="text"><![CDATA[1 Android窗口模型理解View工作原理之前，有几个基本概念需要阐述清楚： 1.1 WindowWindow是一个抽象类，代表的就是手机屏幕，其具体实现是PhoneWindow，Android中所有的视图都是通过Window来呈现的，无论是Activity、Dialog还是Toast，它们的视图实际上都是依附在Window上，因此Window实际上是View的直接管理者。 1.2 ViewRoot和DecorViewViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的工作原理同ViewRoot紧密相连. DecorView是Activity的顶级View，包含标题栏和内容栏，内容栏是一定的存在的，而且其id为android.R.id.content，通过setContentView()将布局文件添加到内容栏中，这篇文章有助于我们理解 12345// 获取内容栏ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);// 获取我们通过setContentView()所设置的ViewView view = viewGroup.getChildAt(0)； Window，Activity，DecorView，ContentView等基本概念，通过图来说明 1.3 DecorView的创建过程View离不开DecorView，了解DecorView的创建过程对于理解View的工作原理大有裨益。以一个简单例子来引入：12345678public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main_activity_layout); &#125;&#125; 再来追踪下Activity的setContentView()方法：12345678public class Activity extends ContextThemeWrapper &#123; ... public void setContentView(int layoutResID) &#123; getWindow().setContentView(layoutResID); // 调用PhoneWindow的setContentView来创建DecorView对象 initWindowDecorActionBar(); &#125; &#125; 接下来进入到PhoneWindow中看看DecorView是如何被创建的：1234567891011public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; ... public void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); // 这里创建DecorView. &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); // 这里不是很明白为啥要移除所有的view？？ &#125; ... &#125;&#125; 进入到installDecor()中进一步分析：12345678910111213public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; ... private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); // 创建DecorView对象mDecor. ... &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); ... &#125; &#125;&#125; 进入generateDecor()方法中：123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; 方法很简单，就是new一个DecorView对象。但是此时创建的DecorView仅仅是一个空白的FrameLayout，接下来便是通过generateLayout()方法初始化DecorView的结构：1234567protected ViewGroup generateLayout(DecorView decor) &#123; ... View view = mLayoutInflater.inflate(layoutResource, null); decor.addView(view, new ViewGroup.LayoutParams(FILL_PARENT, FILL_PARENT)); ViewGroup contentParent = (ViewGroup) findViewById(ID_ANDROID_CONTENT); ...&#125; 源码中这个方法很长，但其主要作用就是加载android.R.id.content这个布局文件，然后添加到DecorView中，并初始化mContentParent。以上便完成了DecorView结构的初始化工作。 接下来再回到setContentView()方法中：12345678public void setContentView(int layoutResID) &#123; ... if (hasFeature(FEATURE_CONTENT_TRANSITIIONS)) &#123; ... &#125; else &#123; mLayoutInflator.inflate(layoutResID, mContentParent); // 这里最终将我们设置的布局文件通过inflate加入到mContentParent中. &#125;&#125; 以上过程只是完成了DecorView的创建和初始化工作，创建好了之后实际上DecovView仍旧处于INVISIBLE状态，还需要将DecorView添加到屏幕上，这时就需要用到WindowManager。分下Activity的启动过程，首先调用ActivityThread的handleResumeActivity，接着调用Activity.onResume()方法，接着调用Activity.makeVisible()方法：12345678void makeVisible() &#123; if (!mWindowAdded) &#123; WindowManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; 以上过程便DecorView的整个创建以及初始化过程，这种见省略了不少其他的操作。那么，DecorView是如何同ViewRootImpl关联上的呢？ 继续以上的分析：1wm.addView(mDecor, getWindow().getAttributes()); WindowManager的真实实现是WindowManagerImpl，因此实际上调用的也是WindowManagerImpl.addView()方法：123456@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); // 实际上调用的是WindowManagerGlobal.addView()方法 mGlobal.addView(view, params, mDisplay, mParentWindow);&#125; 接下来进入到WindowManagerGlobal.addView()方法中，这个方法比较复杂，这里作节选：123456789101112131415161718public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ... root = new ViewRootImpl(view.getContext(), display); // 创建View和与之对应的ViewRoot对象 view.setLayoutParams(wparams); mViews.add(view); // 保存view到WindowManagerGlobal中 mRoots.add(root); // 保存ViewRoot到WindowManagerGlobal中 mParams.add(wparams); // 保存布局参数到WindowManagerGlobal中 ... &#125; ... root.setView(view, wparams, panelParentView);&#125; 在这个方法中，创建View对应的ViewRoot对象，ViewRoot控制着一个视图的结构，里面包含于WindowManager通信的Binder对象、View所在界面的ContextImpl、DecorView等信息。 接下来进入到ViewRootImpl.setView()方法中：1234567891011public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; ... requestLayout(); // 首次执行layout，这里会触发onAttachToWindow()和创建Surface，需进一步追踪！！ ... &#125; &#125;&#125; 接下来看一下requestLayout()方法：1234567public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 再进入到scheduleTraversals()方法中：12345678910111213141516171819202122232425void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; ... mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); // 这里重点就是mTraversalRunnable ... &#125;&#125;// mTraversalRunnable定义final TraversalRunnable mTraversalRunnable = new TraversalRunnable();final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;void doTraversal() &#123; if (mTraversalScheduled) &#123; ... performTraversals(); // ！！！！！！大BOSS终于来了！！！！！！ ... &#125;&#125; OKAY！！终于要开始进入到View的绘制流程了！ 2 View的绘制View的绘制绘制流程是从performTraversals()方法开始的，经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽和高，layout用来确定View在父容器中的位置，draw负责将View绘制在屏幕上。其大致流程如下图所示： 上图描述了View绘制的大致流程。下面将详细分析每一步的流程： 2.1 理解MeasureSpec理解MeasureSpec对理解View的测量过程是必须的，字面意思就是“测量说明书”，MeasureSpec从始至终一直参与者View的测量过程。 (1) MeasureSpecMeasureSpec是一个32为的int值，高2为代表SpecMode，意思就是测量模式，低30位代表SpecSize，是指在某种测量模式下的规格大小。123456789101112131415161718192021private static final int MODE_SHIFT = 30;private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;private static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;private static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;private static final int AT_MOST = 2 &lt;&lt; MODE_SHFIT;public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125;public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK);&#125;public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK);&#125; 从上面代码可以看出，MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为方便操作，其提供了打包和解包操作。 SpecMode有三类：UNSPECIFIED父容器不对View作任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。 EXACTLY父容器已经检测出View所需的精确尺寸大小，这个时候View的最终大小就是SpecSize所指定的值，它对应于LayoutParams中的match_parent和具体的数值这两种模式。 AT_MOST父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么值要看不同View的具体实现，它对应于LayoutParams中的wrap_content。 (2) MeasureSpec和LayoutParams的对应关系正常情况下，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽/高。需要注意的是，MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步确定View的宽/高。 DecorView的MeasureSpec创建过程在RootViewImpl中的measureHierarchy方法中：12345678private boolean measureHierarchy(final View host, final WindwoManager.LayoutParams lp, final Resource res, final int desiredWindowWidth, final int desiredWindowHeight) &#123; ... childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ...&#125; 其中，childWidthMeasureSpec/childHeightMeasureSpec分别为屏幕的尺寸，不难看出，对于顶级DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams共同确定。 普通View的MeasureSpec创建过程对普通的View而言，其measure过程由ViewGroup传递而来。先来看看ViewGroup的measureChildWidhMargins()方法：123456789101112131415protected void More ...measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); // 获取子元素的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); // 对子元素进行measure过程 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 上述代码展示了对ViewGroup中的子元素进行measure过程，在调用子元素的measure方法之前，会先通过getChildMeasureSpec()方法获取子元素的MeasureSpec，同时不难发现，子元素MeasureSpec的创建同父容器的MeasureSpec和子元素本身的LayoutParams直接相关，此外还与子元素的margin及padding有关。getChildMeasureSpec()方法则更进一步说明了子元素MeasureSpec计算过程，具体有兴趣的可以自行了解下。 至此，获取MeasureSpec过程也就结束了，这是View绘制的第一步。 2.2 View的measure过程measure过程需分2中情况来讨论：原始的View和ViewGroup。对于原始的View，通过measure方法就完成了自身的测量过程，对于ViewGroup，除了完成自己的测量之外，还要去递归遍历调用所有子元素的measure方法。 (1) View的measure过程承接上文，在View的measure()方法中，会调用onMeasure()方法，来看看onMeasure()方法：1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 可以看出，onMeasure()方法相当简单，setMeasuredDimension()顾名思义，就是设置View的宽/高，如何设置？来看下getDefaultSize()方法：123456789101112131415public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 简单来看，对绝大多数情况（AT_MOST和EXACTLY），getDefaultSize()返回的就是specSize，而这个specSize就是View的测量大小。但要注意，View最终的大小是在layout阶段确定的，但是几乎在所有情况下View的测量大小总是和最终的大小是相等的。UNSPECIFIED较少用到，追踪源码其实也挺简单，这里不作讨论。 (2) ViewGroup的measure过程对于ViewGroup来说，除了完成自己的measure过程之外，还会递归遍历所有的子元素。ViewGroup是一个抽象类，没有重写View的onMeasure()方法，但是提供了measureChildren()的方法：12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++ i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthSpec, heightMeasureSpec); &#125; &#125;&#125; 上述代码中，ViewGroup进行measure时，会对每一个子元素进行measure，再来看看measureChild()方法：12345678protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 如此便最终实现了ViewGroup的测量过程！！但，归根到底，ViewGroup并没有定义测量的具体过程，这主要是因为ViewGroup是一个抽象类，其测量过程中的onMeasure()方法需要各个子类去具体的实现，比如LinearLayout、RelativeLayout等各自定义了自己的onMeasure()方法。由于ViewGroup子类的不同的布局特性，导致它们的测量细节各不相同，因此ViewGroup并没有实现onMeasure()方法，而是交给具体的子类来实现。具体的可以参考LinearLayout的onMeasure()过程，这里不作细述。 (3) 一个问题刚入门Android的时候，特别是在做Dolphin中的一些动画时候，经常要获取某个特定View个宽/高，当时傻啦吧唧的试图在Activity的onCreate()中获取（因为View的宽/高需要比较早知道），可是无论是view.getWidth()还是view.getMeasuredWidth()，返回的都是0！无赖在onResume()中获取，发现偶尔不为0，但大多数时候都为0！！不知道有没有和我一样SHA的。 实际上，在onCreate()、onStart()、onResume()中都无法正确的获取View的宽/高信息，这是因为View的measure过程和Activity的生命周期不是同步执行的！无法保证在Activity的这些方法调用时，View的测量过程已经完成了，那么如果一定要获取View的宽/高信息呢？该如何做？下面提供几种方法： Activity/View#onWindowFoucusChanged()方法中获取onWindowFoucusChanged()方法说明View已经初始化完毕，宽/高信息已经准备好了，在这里获取View的宽/高信息基本是正确的。(1) View.post(runnable)方法123456789101112@Overrideprotected void onCreate() &#123; super.onCreate(); ... view.post(new Runnable() &#123; @Override public void run() &#123; int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); &#125; &#125;);&#125; (1) ViewTreeObserver方法方法使用ViewTreeObserver的回调方法也可以完成View的测量，比如在OnGlobalLayoutListener这个接口中做。123456789ViewTreeObserver observer = view.getViewTreeObserver();observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; ... int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); &#125;&#125;); 2.3 View的Layout过程Layout过程的作用是ViewGroup用来确定其子元素的位置，当ViewGroup位置被确定之后，它在onLayout()中会遍历所有子元素并调用其layout()方法，在layout()方法中onLayout()方法被调用，最终确定所有元素的位置。 也就是：layout()方法确定View本身的位置，而onLayout()方法确定所有子元素的位置。 先来看看View的layout()方法中的关键代码：12345678910// 4个参数分别表示4个顶点public void layout(int l, int t, int r, int b) &#123; ... boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ... &#125;&#125; 从上面代码可以看出，layout()方法的大致流程是：首先通过setFrame()方法来设置View的4个顶点位置，进入setFrame()方法不难看出，其实也就是设置mLeft, mRight, mTop, mBottom这四个值，View的4个顶点确定之后，View在父容器中的位置也就确定了；然后，调用onLayout()方法，这个方法的作用是父容器确定其子元素的位置，onLayout()在View中并无具体的实现，同onMeasure()方法类似，其具体实现依赖于具体的布局，因此View和ViewGroup均没有真正实现onLayout()方法，我们以LinearLayout中的onLayout()方法为例：1234567protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutVertical(l, t, r, b); &#125;&#125; 继续看看layoutVertical()实现：1234567891011121314151617181920void layoutVertical(int left, int top, int right, int bottom) &#123; ... int count = getVirtualChildCount(); ... for (int i = 0; i &lt; count; i ++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); ... setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); &#125; &#125;&#125;private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; 可以看出，此方法遍历所有子元素并调用setChildFrame()方法来为子元素指定对应的位置，setChildFrame()中调用了View的layout()方法，最终又回到了上面所提到的情况。 回到前文所提到的：绝大多数情况下，View的测量宽/高和最终的宽/高是相等的，在这里也可以得到证明：1234567public final int getWidth() &#123; return mRight - mLeft;&#125;public final int getHeight() &#123; return mBottom - mTop;&#125; 而在setFrame()方法中，12345678protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... // 这里对顶点参数进行赋值 mLeft = left; mTop = top; mRight = right; mBottom = bottom;&#125; 从上面的onLayout()方法中知道，12right = left + measuredWidth;bottom = top + measuredHeight; 因此，View的默认实现中，View的测量宽/高和最终的宽/高是相等的。除了一下情况：1234// 重写View的layout方法public void layout(int l, int t, int r, int b) &#123; super.layout(l, t, r + 100. b + 100);&#125; 这种情况下，View的最终宽/高总是比测量宽/高大100px。另外一种情况是，View需要多次measure测能确定自己的测量宽/高，前几次的测量过程中，其测量出来的宽/高有可能和最终的宽/高不一致，但最终来讲，测量宽/高还是和最终的宽/高相同。 2.4 View的draw过程View的draw()过程比较简单，它的作用是将View绘制在屏幕上，draw()过程分为以下几部：(1) 绘制背景;(2) 绘制自己；(3) 绘制children;(4) 绘制装饰。 来简要看下draw()方法的实现：12345678910111213141516171819202122232425public void draw(Canvas canvas) &#123; ... // Step 1, draw the background, if needed. if (!dirtyOpaque) &#123; drawableBackground(canvas); &#125; // skip stdp 2 &amp; 5 if possible (common case) if (!verticalEdges &amp;&amp; !horizontalEdge) &#123; // step 3, draw the content if (!dirtyOpaque) &#123; onDraw(canvas); &#125; // step 4, draw the children dispatchDraw(canvas); // step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); ... // we're done... return; &#125;&#125; View绘制过程的传递是通过dispatchDraw()完成的，dispatchDraw()会遍历调用所有子元素的draw()方法，如此实现draw事件的层层传递。 3 References[1] Android源码：http://grepcode.com/search/?query=google+android&amp;entity=project，本文所有代码基于Android 5.1.1_r1[2] 《Android开发艺术探索》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[About Me]]></title>
      <url>https://xdrush.github.io/2016/01/16/About_XDRush/</url>
      <content type="text"><![CDATA[Education ExperienceHigh Middle School.2005/9~2008/6: Hubei Huanggang Middle Shcool BS.2008/9~2012/6：Huazhong University of Science of TechnologySchool of Automation……………………………………………………MS.2012/9~2015/6: Huazhong University of Science of TechnologyElectronics and Information Engineering Working Experience2017/6~Now: 搜狗基础算法副研究员负责信息流广告/网盟广告物料优化，主要利用NLP，深度学习等算法优化广告物料。 2015/7~2017/4： MoboTapAndroid开发工程师 &amp; 机器学习研究员早期是一名Android开发工程师，先后负责开发Dolphin Browser、Phone Clean、CY Security等多款应用，产品总DAU 500w+；负责研发的应用广告SDK集中在公司全系产品中；从2016年开始主要从事机器学习/深度学习在商业变现上的应用，利用LR/FM等算法在APP中推荐广告。 SkillsC/C++，Java，Python，Linux，Android，Matlab，Deep Learning，Machine Learning ContactsEmail: xdrushing@gmail.com or xudong_hust@126.comWeChat: XDRush]]></content>
    </entry>

    
  
  
</search>
