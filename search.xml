<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[读书笔记之《特斯拉之父：埃隆·马斯克传》]]></title>
      <url>https://xdrush.github.io/2017/04/17/ReadingNotes-%E5%9F%83%E9%9A%86%E9%A9%AC%E6%96%AF%E5%85%8B%E4%BC%A0/</url>
      <content type="text"><![CDATA[马斯克简介马斯克与特斯拉马斯克之SpaceX]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仿斗鱼Android客户端结构实现]]></title>
      <url>https://xdrush.github.io/2017/01/26/%E4%BB%BF%E6%96%97%E9%B1%BCAndroid%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="text"><![CDATA[1. 实现说明本文旨在通过TabLayout和ViewPager打造最常见的底部导航栏+多Tab结构的Android App。 1.1 斗鱼Android客户端结构先来简要看看斗鱼客户端基本结构： 首页结构 直播页结构 1.2 模仿结构示意图模仿首页 模仿直播页 其中，首页和直播页最大的区别是首页只有5个tab，儿直播页则有10个tab，其中几个tab又有若干个子Tab。 2. 代码实现2.1 主体代码实现采用Android官方提供的TabLayout+ViewPager结构来实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 点击每个底部导航栏中的子项所对应的基类Fragment. * * Created by xdrush on 2017/1/26. */public abstract class BaseItemFragment extends Fragment &#123; TabLayout mTabLayout; ViewPager mViewPager; ItemFragmentAdapter mFragmentAdapter; List&lt;Fragment&gt; mFragmentList; List&lt;String&gt; mTitleList; @Override public View onCreateView(LayoutInflater layoutInflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = layoutInflater.inflate(R.layout.main_content_fragment_layout, container, false); setupViews(view); initFragment(); setupFragment(); return view; &#125; private final void setupViews(View view) &#123; mTabLayout = (TabLayout) view.findViewById(R.id.tablayout); mViewPager = (ViewPager) view.findViewById(R.id.viewpager); mFragmentList = new ArrayList&lt;&gt;(); mTitleList = new ArrayList&lt;&gt;(); &#125; private final void setupFragment() &#123; int size = mTitleList.size(); if (getActivity() == null || 0 == size) &#123; return; &#125; for (int i = 0; i &lt; size; i ++) &#123; mTabLayout.addTab(mTabLayout.newTab().setText(mTitleList.get(i))); &#125; // 方法一：有bug， 没有回弹.// mFragmentAdapter = new ItemFragmentAdapter(getActivity().getSupportFragmentManager(),// mFragmentList, mTitleList); // 方法二：bug fixed， 有回弹. mFragmentAdapter = new ItemFragmentAdapter(getChildFragmentManager(), mFragmentList, mTitleList); mViewPager.setAdapter(mFragmentAdapter); mTabLayout.setupWithViewPager(mViewPager); setTabLayoutMode(); &#125; public abstract void setTabLayoutMode(); public abstract void initFragment();&#125;/** * 首页Fragment. * * Created by xdrush on 2017/1/26. */public class MainPageFragment extends BaseItemFragment &#123; private static final int TAB_COUNTS = 5; private static final String[] TITLE = &#123;"推荐", "手游", "娱乐", "游戏", "趣玩", ""&#125;; @Override public void initFragment() &#123; for (int i = 0; i &lt; TAB_COUNTS; i ++) &#123; String title = TITLE[i]; mTitleList.add(title); BaseContentFragment fragment = new BaseContentFragment(); fragment.setContent(title); mFragmentList.add(fragment); &#125; mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; BaseContentFragment baseContentFragment = (BaseContentFragment) mFragmentList.get(position); baseContentFragment.setContent(mTitleList.get(position)); &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); &#125; @Override public void setTabLayoutMode() &#123; mTabLayout.setTabMode(TabLayout.MODE_FIXED); &#125;&#125;/** * 直播页面对应的Fragment. * * Created by xdrush on 2017/1/26. */public class OnAirPageFragment extends BaseItemFragment &#123; private static final int TAB_COUNTS = 10; private static final String[] TITLE = &#123;"常用", "全部", "热门游戏", "移动游戏", "鱼乐星天地", "颜值", "科技", "文娱天堂", "正能量", "体育直播"&#125;; @Override public void initFragment() &#123; for (int i = 0; i &lt; TAB_COUNTS; i ++) &#123; String title = TITLE[i]; mTitleList.add(title); BaseContentFragment fragment = new BaseContentFragment(); fragment.setContent(title); mFragmentList.add(fragment); &#125; &#125; @Override public void setTabLayoutMode() &#123; mTabLayout.setTabMode(TabLayout.MODE_SCROLLABLE); &#125;&#125; 上面涉及到的MainPageFragment和OnAirPageFragment分别是点击底部“首页”和“直播”所对应的页面，其中BaseContentFragment类对应的每个子Tab的Fragment。12345678910111213141516171819202122232425262728/** * 每个Tab对应的Fragment. * * Created by xdrush on 2017/1/26. */public class BaseContentFragment extends Fragment &#123; private TextView mContentTv; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.base_content_fragment_layout, container, false); setupViews(view); return view; &#125; private void setupViews(View view) &#123; mContentTv = (TextView) view.findViewById(R.id.content); &#125; public void setContent(String content) &#123; if (null == mContentTv) &#123; return; &#125; mContentTv.setText(content); &#125;&#125; 对应的xml文件如下：123456789101112131415161718192021222324252627282930313233343536373839// main_content_fragment_layout.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tablayout" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="#389d00" app:tabIndicatorColor="#ffff00" app:tabSelectedTextColor="#CD0000" app:tabTextColor="#ffffff"/&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewpager" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" /&gt;&lt;/LinearLayout&gt;// base_content_fragment_layout.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/content" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="hello world" android:layout_gravity="center"/&gt;&lt;/LinearLayout&gt; 2.2 注意问题可能你会注意到上面有个注释bug/bug fixed，对的，如果采用方法一来实现的话，将会出现下图所示现象： 如上图所示：将会导致indicator和title对不上，整个ViewPager没有回弹过程，导致以上bug。这个问题用方法二即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式跟风作之装饰者模式]]></title>
      <url>https://xdrush.github.io/2017/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B7%9F%E9%A3%8E%E4%BD%9C%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="text"><![CDATA[1. 装饰者模式概述1.1 定义装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。 1.2 使用场景在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；类已定义为不能被继承（譬如final类）。 1.3 装饰者模式构成Component（抽象构件）它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 ConcreteComponent（具体构件）它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。 Decorator（抽象装饰类）它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 ConcreteDecorator（具体装饰类）它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 2. 使用示例本例模拟咖啡店点单系统：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * This is the abstract component（抽象构件）. * * Created by xdrush on 2017/1/25. */public abstract class Beverage &#123; String mDescription = "Unknown Beverage"; public String getDescription() &#123; return mDescription; &#125; public abstract double cost();&#125;/** * This is Decorator（抽象装饰类）. * The decorator should be abstract. * * Created by xdrush on 2017/1/25. */public abstract class CondimentDecorator extends Beverage &#123; public abstract String getDescription();&#125;/** * This is concrete object to be decorated（具体构件，被装饰者）. * * Created by xdrush on 2017/1/25. */public class Espresso extends Beverage &#123; public Espresso() &#123; mDescription = Espresso.class.getSimpleName(); &#125; @Override public double cost() &#123; return 1.29; &#125;&#125;/** * This is the concrete decorator（具体装饰者）. * * Created by xdrush on 2017/1/25. */public class Mocha extends CondimentDecorator &#123; Beverage mBeverage; public Mocha(Beverage beverage) &#123; mBeverage = beverage; &#125; public String getDescription() &#123; return mBeverage.getDescription() + ", Mocha"; &#125; @Override public double cost() &#123; return 0.20 + mBeverage.cost(); &#125;&#125; 3. 总结3.1 装饰模式优点 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。 可以通过一种动态的方式在运行时选择不同的具体装饰类，从而实现不同的行为。 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。 3.2 装饰模式缺点 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java进阶之SOLID原则]]></title>
      <url>https://xdrush.github.io/2017/01/24/Java%E8%BF%9B%E9%98%B6%E4%B9%8BSOLID%E5%8E%9F%E5%88%99/</url>
      <content type="text"><![CDATA[1. 什么是SOLID原则？S.O.L.I.D原则是面向对象设计和编程中几个重要的编码原则首字母的缩写；SRP：The Single Responsibility Principle，单一职责原则OCP：The Open Closed Principle，开放封闭原则LSP：The Liskov Substitution Principle，里氏替换原则ISP：The Interface Segregation Principle，接口分离原则DIP：The Dependency Inversion Principle，依赖倒置原则下面将详细讲解每种原则所代表的意义。 2. SRP（单一职责原则）当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。 3. OCP（开放封闭原则）软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。 通过增加代码来扩展功能，而不是修改已经存在的代码。 若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。 OCP支持替换的服务，而不用修改客户模块。 示例如下：1234567891011public boolean sendByEmail(String addr, String title, String content) &#123;&#125;public boolean sendBySMS(String addr, String content) &#123;&#125;// 在其它地方调用上述方法发送信息sendByEmail(addr, title, content);sendBySMS(addr, content); 如果现在又多了一种发送信息的方式，比如可以通过微信来发送信息，那么不仅需要增加一个方法sendByWeChat()，还需要在调用它的地方进行修改，违反了OCP原则，更好的方式是抽象出一个Send接口，里面有个send()方法，然后让SendByEmail和SendBySMS去实现它既可。这样即使多了一个通过WeChat发送的请求，那么只要再添加一个SendByWeChat实现类实现Send接口既可。这样就不需要修改已有的接口定义和已实现类，很好的遵循了OCP原则。12345678910111213141516171819202122232425262728public interface Send &#123; void send(String addr, String title, String content);&#125;public class SendByEmail implements Send &#123; @Override public void send(String addr, String title, String content) &#123; System.out.println("SendByEmail"); &#125;&#125;public class SendBySMS implements Send &#123; @Override public void send(String addr, String title, String content) &#123; System.out.println("SendBySMS"); &#125;&#125;public class SendByWeChar implements Send &#123; @Override public void send(String addr, String title, String content) &#123; System.out.println("SendByWeChar"); &#125;&#125; 如此，即很好的满足了OCP原则。 4. LSP（里氏替换原则）当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法； 子类中可以增加自己特有的方法； 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松； 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 举个简单的例子来说明，我们需要完成一个两数相减的功能，由类A来负责：12345678910111213class A &#123; public int func1 (int a, int b) &#123; return a - b; &#125; &#125; public class Client &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println("100 - 50 = " + a.func1(100, 50)); System.out.println("100 - 80 = " + a.func1(100, 80)); &#125; &#125; 后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能： 两数相减。 两数相加，然后再加100。 由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：123456789101112131415161718class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125; public int func2(int a, int b) &#123; return func1(a, b) + 100; &#125; &#125; public class Client&#123; public static void main(String[] args) &#123; B b = new B(); System.out.println("100 - 50 = " + b.func1(100, 50)); System.out.println("100 - 80 = " + b.func1(100, 80)); System.out.println("100 + 20 + 100 = " + b.func2(100, 20)); &#125; &#125; 运行，不难发现肯定是无法获得正确的结果的，这就印证了上述观点。 5. ISP（接口分离原则）不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口要好。 客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。这里比较好理解，就不举例啦。 6. DIP（依赖注入或倒置原则） 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 抽象不应该依赖于细节，细节应该依赖于抽象 先让我们从宏观上来看下，举个例子，我们经常会用到宏观的一种体系结构模式–layer模式，通过层的概念分解和架构系统，比如常见得三层架构等。那么依赖关系应该是自上而下，也就是上层模块依赖于下层模块，而下层模块不依赖于上层，如下图所示。 这应该还是比较容易理解的，因为越底层的模块相对就越稳定，改动也相对越少，而越上层跟需求耦合度越高，改动也会越频繁，所以自上而下的依赖关系使上层发生变更时，不会影响到下层，降低变更带来的风险，保证系统的稳定。上面是立足在整体架构层的基础上的结果，再换个角度，从细节上再分析一下，这里我们暂时只关注UI和Service间的关系，如上面UI和Service这样的依赖关系会有什么样的问题？ 当需要追加提供一种新的Service时，我们不得不对UI层进行改动，增加了额外的工作。 这种改动可能会影响到UI，带来风险。 改动后，UI层和Logic层都必须重新再做Unit testing。 那么具体怎么优化依赖关系才能让模块或层间的耦合更低呢？想想前面讲的OCP原则吧，观点是类似的。我们可以为Service追加一个抽象层，上层UI不依赖于Service的details，UI和Service同时依赖于这个Service的抽象层。如下图是我们的改进后的结果。这样改进后会有什么好处呢？ Service进行扩展时，一般情况下不会影响到UI层，UI不需要改动。 Service进行扩展时，UI层不需要再做Unit testing。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式跟风作之观察者模式]]></title>
      <url>https://xdrush.github.io/2017/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="text"><![CDATA[1 观察者模式简介观察者模式定义了一种一对多的依赖关系，让多个Observer对象同时监听某个Observable（被观察者）对象。当Observable对象在状态发生变化时，会通知所有（或者部分）Observers，让这些observers能够自动更新自己。 2 观察者模式的组成2.1 抽象Observable角色把所有对观察者对象的引用保存在一个集合中，每个抽象Observable角色都可以有任意数量的Observer。抽象Observable提供一个接口，可以增加、删除Observer。一般用一个抽象类和接口来实现。 2.2 抽象Observer角色为所有具体的Observer定义一个接口，在得到Observable的通知时更新自己。 2.3 具体Observable角色在具体Observable内部状态改变时，给所有注册过的Observers发出通知。具体Observable通常是抽象Observable的一个子类实现。 2.4 具体Observer角色该角色实现抽象Observer所要求的接口，以便使自己的状态与Observable的状态相协调。通常用一个子类来实现。如果需要，具体Observer角色可以保存一个指向具体Observable角色的引用。 3 观察者模式实现3.1 抽象Observer实现123456/** * 抽象Observer角色 */public interface Watcher &#123; void update(String str);&#125; 3.2 抽象Observable实现1234567891011/** * 抽象Observable角色. */public interface Watched &#123; void addWatcher(Watcher watcher); void removeWatcher(Watcher watcher); void notifyWatchers(String str);&#125; 3.3 具体Observer实现12345678910/** * 具体的Observer实现 */public class ConcreteWatcher implements Watcher &#123; @Override public void update(String str) &#123; System.out.println(str); &#125;&#125; 3.4 具体Observable实现123456789101112131415161718192021222324252627282930313233343536/** * 具体Observable实现 */public class ConcreteWatched implements Watched &#123; private List&lt;Watcher&gt; mWatcherList = new ArrayList&lt;&gt;(); @Override public void addWatcher(Watcher watcher) &#123; if (null == watcher) &#123; return; &#125; mWatcherList.add(watcher); &#125; @Override public void removeWatcher(Watcher watcher) &#123; if (null == watcher) &#123; return; &#125; if (0 == mWatcherList.size()) &#123; return; &#125; mWatcherList.remove(watcher); &#125; @Override public void notifyWatchers(String str) &#123; for (Watcher watcher : mWatcherList) &#123; watcher.update(str); &#125; &#125;&#125; 3.5 测试用例12345678910111213141516public class ObservableTest &#123; public static void main(String[] args) &#123; Watched employees = new ConcreteWatched(); Watcher employee1 = new ConcreteWatcher(); Watcher employee2 = new ConcreteWatcher(); Watcher employee3 = new ConcreteWatcher(); employees.addWatcher(employee1); employees.addWatcher(employee2); employees.addWatcher(employee3); employees.notifyWatchers("xdrush"); &#125;&#125; 4 Java中的观察者模式4.1 Java中的Observer和ObservableJava在java.util.*;包中提供了现成的观察者模式实现，具体的两个类分别是Observer和Observable；这两个类充当上节中的抽象Observer和抽象Observable功能。 4.2 使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 首先定义SimpleObserverpublic class SimpleObserver implements Observer &#123; public SimpleObserver(SimpleObservable observable) &#123; observable.addObserver(this); &#125; @Override public void update(Observable observable, Object object) &#123; if (observable instanceof SimpleObservable) &#123; SimpleObservable simpleObservable = (SimpleObservable) observable; System.out.println("data has changed to -&gt; " + simpleObservable.getData()); &#125; &#125;&#125;// 定义SimpleObservablepublic class SimpleObservable extends Observable &#123; private int mData = 0; public void setData(int data) &#123; if (this.mData == data) &#123; return; &#125; this.mData = data; setChanged(); notifyObservers(); &#125; public int getData() &#123; return mData; &#125;&#125;// 简单测试public class ObservableTest &#123; public static void main(String[] args) &#123; SimpleObservable observable = new SimpleObservable(); SimpleObserver observer1 = new SimpleObserver(observable); SimpleObserver observer2 = new SimpleObserver(observable); SimpleObserver observer3 = new SimpleObserver(observable); observable.setData(5); observable.setData(6); observable.setData(6); &#125;&#125; 4.3 ObserverObserver接口只提供了一个方法update()：123public interface Observer &#123; void update(Observable observable, Object object);&#125; 4.4 ObservableObservable提供了几个关键的接口：(1) setChanged()用来设置一个内部标志位注明数据发生了变化；只有setChanged()方法被调用，notifyObservers()方法才会被正确的执行；这在notifyObservers()方法源码中有具体的体现； (2) notifyObservers()/notifyObservers(Object object)通知所有的Observers数据发生了变化，这时所有的Observer会自动调用复写好的update(Observable, Object)方法来做一些处理。其中Object参数可以用来作为ID，然后在所有的Observer中作判断，每个Observer判断只有接收到的参数ID属于自己的才做一些处理。 其他的方法可直接看源码，比较简单，易于理解。 4.5 使用注意事项在Observer对象被销毁前一定要用deleteObserver将其从列表中删除，否则因为在Observable中还存在对象的引用，导致Observer不会被垃圾收集，曹成内存泄漏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一篇文章带你了解Android之Gradle]]></title>
      <url>https://xdrush.github.io/2017/01/17/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Android%E4%B9%8BGradle/</url>
      <content type="text"><![CDATA[1 Groovy &amp; Gradle基础1.1 Groovy这里不作介绍，像写脚本一样写Java，也是运行在JVM上。比较简单，是Gradle基础，当然，也可以用纯Java来写gradle。 1.2 GradleGradle是一个工具，同时它也是一个编程框架。使用这个工具可以完成app的编译打包等工作，当然也可以用它干其他的事情。Gradle相关文档见这里，我们编写所谓的编译脚本，其实就是在用Gradle提供的API。Gradle是一个框架，它提供了很多基本组件：Gradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的task。比如一个Android APK的编译可能包含：Java源码编译task、资源编译task、JNI编译task、lint检查task、打包生成APK的task、签名task等。每个Project具体包含多少个task是有编译脚本指定的插件决定的，这个在后面会讲到。 Gradle作为一个框架，它负责定义流程和规则。而具体的编译工作则是通过插件的方式来完成的。比如编译Java有Java插件，编译Groovy有Groovy插件，编译Android APP有Android APP插件，编译Android Library有Android Library插件等等。 1.2.1 Gradle对象Gradle主要有三种对象，这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：(1) Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。(2) Project对象：每一个build.gradle会转换成一个Project对象。(3) Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。 其中最重要的就是project对象，project包含若干个tasks，在project中，我们要做如下工作： 加载插件 配置插件 设置属性 加载插件加载插件是调用它的apply函数，我们常见的就有以下几个：123apply plugin: 'com.android.library'apply plugin: 'comn.android.application'apply from: "$project.rootDir/build.gradle" // 加载另外一个**.gradle文件，通常定义一些公共的模块 配置插件配置插件这里就不作多说，后文会详细讲到。 设置属性如果是单个脚本，则不需要考虑属性的跨脚本传播，但是Gradle往往包含不止一个build.gradle文件，比如我设置的utils.gradle，settings.gradle。如何在多个脚本中设置属性呢？ Gradle提供了一种名为extra property的方法。extra property是额外属性的意思，在第一次定义该属性的时候需要通过ext前缀来标示它是一个额外的属性。定义好之后，后面的存取就不需要ext前缀了。ext属性支持Project和Gradle对象。即Project和Gradle对象都可以设置ext属性。后文会讲到。 2 Android Gradle简介目前Android基本上都是采用Gradle进行构建，针对大家对gradle用法的一些疑惑，下面将详细剖析gradle在android构建中的用法。 2.1 Android Gradle目录结构首先来看看一个典型的Android工程中gradle的结构： 上图基本就是目前典型的Android结构（Dolphin里面的更为复杂，相对Gradle用法有进一步了解的，请参考Dolphin），万变不离其宗，理解了这些，再复杂的配置都能清晰看懂。 2.2 Top Level GradleTop Level Gradle用于配置所有Module的属性，包括一些公共的方法、公共的依赖项。一般包含3个文件，build.gradle、settings.gradle、gradle.properties。下面来依次了解下每个文件是用来干什么的。 2.2.1 build.gradle文件 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125;/** * 定义外部属性,所有Module中均用这里的配置,避免Project修改时所有Module都要更改. */ext &#123; // Android config androidBuildToolsVersion = '23.0.2' androidMinSdkVersion = 16 androidTargetSdkVersion = 23 androidCompileSdkVersion = 23 androidVersionCode = 1 androidVersionName = '1.0' // libraries config supportVersion = '23.1.1' picasso = '2.5.2' commonDependencies = [ appcompatV7 : "com.android.support:appcompat-v7:$&#123;supportVersion&#125;", design : "com.android.support:design:$&#123;supportVersion&#125;", picasso : "com.squareup.picasso:picasso:$&#123;picasso&#125;" ]&#125; 接下来来具体看看top level构建脚本下每个节点代表什么。 buildscript节点buildscript节点是运行该构建脚本所需要用到的依赖文件，repositories则指定了依赖文件的查找位置。一般而言，这个script block都写在脚本开头，声明这个脚本本身运行所需的依赖。 allprojects设置当前project以及所有sub project中依赖文件的查找路径。 task clean定义一个新的task叫做clean，类型为Delete。Android Plugin内置了clean方法，但是该方法在module中，module中内置的clean方法只会清理module中的文件并删除module中的build目录，但是工程根目录中的build文件没有被删除。因此，这里定义的clean方法删除根目录下的build文件夹。 2.2.2 settings.gradle文件 示例 1include ':app', ':third_party' 说明管理所有sub project，凡是要被编译的子项目，都要写在这里，gradle按照这个配置递归编译子项目。 2.2.3 gradle.properties配置gradle JVM运行的一些参数，MaxHeapSize之类的，本地环境配置。 2.3 Module Level Gradle模块级的脚本描述的是该模块的编译过程，一般而言，Android用到的有两种： Application：apply plugin: ‘com.android.application’，编译结果为apk Library：apply plugin: ‘com.android.library’，编译结果为aar application插件和library插件内容配置差不多，这里分别用讲述以2中形式来分别配置Module的gradle. 2.3.1 application build.gradle代码示例首先来看第一种方式，直接读取top level的build.gradle中属性值，然后再使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101apply plugin: 'com.android.application'/** * 定义外部属性. */ext &#123; app_name = "Gradle Demo"&#125;/** * 配置Android属性,有很多属性可以配置,具体可以参考&#123;@link com.android.build.gradle.BaseExtension&#125; */android &#123; /** * 获取project配置。 */ def globalConfiguration = rootProject.extensions.getByName("ext") compileSdkVersion globalConfiguration.getAt("androidCompileSdkVersion") buildToolsVersion globalConfiguration.getAt("androidBuildToolsVersion") defaultConfig &#123; applicationId "io.xdrush.com.gradledemo" minSdkVersion globalConfiguration.getAt("androidMinSdkVersion") targetSdkVersion globalConfiguration.getAt("androidTargetSdkVersion") versionCode globalConfiguration.getAt("androidVersionCode") versionName globalConfiguration.getAt("androidVersionName") // manifest占位符替换. manifestPlaceholders = [app_name: app_name] &#125; packagingOptions &#123; exclude 'main/AndroidManifest.xml' &#125; signingConfigs &#123; debug &#123; &#125; /** * 配置Release版签名文件. */ release &#123; keyAlias 'm8u' keyPassword 'com.cyou.m8u' storeFile file("key/m8u") storePassword 'com.cyou.m8u' &#125; &#125; /** * type默认会有debug和release,通常在debug中保留默认值,release中开启混淆,并使用签名文件进行签名. */ buildTypes &#123; debug &#123; // 使用默认值. &#125; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release &#125; &#125;&#125;dependencies &#123; /** * 获取project commonDependencies. */ def dependencies = rootProject.ext.commonDependencies compile dependencies.appcompatV7 compile dependencies.design// compile dependencies.picasso /** * 导入libs文件夹下所有的jar文件. */ compile fileTree(dir: 'libs', include: ['*.jar']) /** * 本地aar依赖. */ compile(name: 'trendingsdk-1.1.1', ext: 'aar') /** * 配置依赖Module. */ compile project(':third_party')&#125;/** * 配置本地libs为依赖查找源,当需要导入本地.aar文件时需要这个. */repositories &#123; flatDir &#123; dirs 'libs' &#125;&#125; 2.3.2 library build.gradle代码示例第二种读取方式则更为简单，直接导入top level的build.gradle，随后可以直接读取其中的属性值：123456789101112131415161718192021222324252627apply plugin: 'com.android.library'apply from: "$project.rootDir/build.gradle"android &#123; compileSdkVersion androidCompileSdkVersion buildToolsVersion androidBuildToolsVersion defaultConfig &#123; minSdkVersion androidMinSdkVersion targetSdkVersion androidTargetSdkVersion versionCode androidVersionCode versionName androidVersionName &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile commonDependencies.appcompatV7 compile fileTree(dir: 'libs', include: ['*.jar'])&#125; 推荐使用这种方式来读取ext值。 3 Gradle之task详解以上还只是了解gradle的基本配置，而gradle构建最最核心的部分是各个插件提供的task，每个task独自执行自己的任务，将构建一步步拆分。 3.1 task简介task是gradle中的一种数据结构，它代表一些要被执行的工作，是构建任务的最基本执行单元，不同的插件有不同的task，每一个task都需要和一个project相关联。 可以看到，上面属于library插件的third_party的task和属于application插件的app的task是不相同的。需要强调的一点是，org.gradle.api.Project这个类是build.gradle构建脚本同gradle交互的主要接口，几乎所有方法都在这个类中能找得到。 3.2 自定义taskProject提供了task函数方便我们创建task，先来看看Project中是如何定义task的：1234567891011121314/** * &lt;p&gt;Creates a &#123;@link Task&#125; with the given name and adds it to this project. Calling this method is equivalent to * calling &#123;@link #task(java.util.Map, String)&#125; with an empty options map.&lt;/p&gt; * * &lt;p&gt;After the task is added to the project, it is made available as a property of the project, so that you can * reference the task by name in your build file. See &lt;a href="#properties"&gt;here&lt;/a&gt; for more details&lt;/p&gt; * * &lt;p&gt;If a task with the given name already exists in this project, an exception is thrown.&lt;/p&gt; * * @param name The name of the task to be created * @return The newly created task object * @throws InvalidUserDataException If a task with the given name already exists in this project. */ Task task(String name) throws InvalidUserDataException; 简要描述就是，一旦task被创建，那么它会被当做project的一个属性，由gradle自动执行，Project有几个关于task的重载版本，功能大致一样。我们在Android中一般看的task是形如下面的格式：12345task myTask // 创建一个名为myTask的tasktask myTask &#123; configure closure &#125; // 重载版本，执行一段闭包task myType &lt;&lt; &#123; task action &#125; // 重载版本task myTask(type: SomeType) // 创建task，并指定type，关于type，后面会讲到task myTask(type: SomeType) &#123; configure closure &#125; “&lt;&lt;”符号表示的task.doLast，”&gt;&gt;”表示task.doFirst，后面的闭包表示task执行完之后/之前，再执行这段闭包。 type:someType又是什么意思呢？其实就是告诉gradle，这个新建的task是从哪个基类task派生而来的。Gradle本身提供了一些通用的task，比如Copy，Delete等等。1234567public class Copy extends AbstractCopyTask &#123; ...&#125;public class Delete extends ConventionTask &#123; ...&#125; 以一个例子来看看task的创建：1234task clean(type: Delete) &#123; println "clean task executing." delete rootProject.buildDir&#125; 这个例子在Top level的build.gradle中创建一个名为clean，type为delete的task，先来看看top level中tasks有什么变化： 可以看到，task一旦创建即被加入到project的task序列中，成为project的一个属性。 这个task具体做什么呢？task里面的这段闭包已经说明了，就是删除根目录下的build文件夹。task里面可以做很多事情，具体下面会介绍到。 3.3 task扩展本小节将在新建task基础上做些扩展，来展示task是如何做更多事情的，相信大家看过之后，不再畏惧gradle，即使不会写但也至少能看得懂。 Android构建给我们已经提供了很多task（可以参考这里），这里结合Android中multidex实现来讲讲task的更多用法：1234567891011121314151617181920tasks.whenTaskAdded &#123; task -&gt; // 遍历所有的task， "-&gt;"就是迭代器的意思 // 如果是create&#123;Debug/Release&#125;MainDexClassList，则执行以下闭包action. if (task.name.startsWith("create") &amp;&amp; task.name.endsWith("MainDexClassList")) &#123; task.doLast &#123; // 该task执行完成之后，再执行以下action，替换分包内容. File tempFile File keepFile if (task.name.contains("Debug")) &#123; tempFile = new File("$project.rootDir/MyProject/keep_in_maindexlist_debug.txt") keepFile = new File("$&#123;project.buildDir&#125;/intermediates/debug/maindexlist.txt") &#125; else if (task.name.contains("Release")) &#123; tempFile = new File("project.rootDir/MyProject/keep_in_maindexlist_release.txt") keepFile = new File("&#123;project.buildDir&#125;/intermediates/release/maindexlist.txt") &#125; tempFile.eachLine("utf-8") &#123; str, linenumber -&gt; keepFile.append(str + "\n") &#125; &#125; &#125;&#125; 上述代码功能大概意思就是江create{Debug/Release}MainDexClassList这个task（对这个不熟的可以参考这里）形成的maindexkeep文件给替换掉。下面来具体分析这个例子： (1) 首先这个在top level的build.gradle中，因为是要干预整个工程的分包，而不是针对某个module的；(2) 这里的意思是将所有的task添加到project中，闭包有一个输入参数：task，这里”task -&gt;”相当于迭代器，闭包内有一个默认参数it，代表的就是tasks，这里没有用到。(3) 获取指定的task，可以根据getByName方法获取指定的task。12345tasks.getByName("assembleRelease") &#123; it.doLast &#123; println "assemble release done." &#125;&#125; 除了上面提到的tasks.whenTaskAdded之外，我们还常见到project.afterEvaluated，它的意思是gradke解析完所有的task之后，并且在具体task开始执行之前，我们可以做的事情。 Android每个project都提供了tasks、project、gradle等内置对象供我们来访问，利用这些对象我们就可以对每个task进行hook，进而能够充分干预整个构建过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从源码角度聊聊View的工作原理]]></title>
      <url>https://xdrush.github.io/2016/07/05/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E8%81%8A%E8%81%8AView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="text"><![CDATA[1 Android窗口模型理解View工作原理之前，有几个基本概念需要阐述清楚： 1.1 WindowWindow是一个抽象类，代表的就是手机屏幕，其具体实现是PhoneWindow，Android中所有的视图都是通过Window来呈现的，无论是Activity、Dialog还是Toast，它们的视图实际上都是依附在Window上，因此Window实际上是View的直接管理者。 1.2 ViewRoot和DecorViewViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的工作原理同ViewRoot紧密相连. DecorView是Activity的顶级View，包含标题栏和内容栏，内容栏是一定的存在的，而且其id为android.R.id.content，通过setContentView()将布局文件添加到内容栏中，这篇文章有助于我们理解 12345// 获取内容栏ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);// 获取我们通过setContentView()所设置的ViewView view = viewGroup.getChildAt(0)； Window，Activity，DecorView，ContentView等基本概念，通过图来说明 1.3 DecorView的创建过程View离不开DecorView，了解DecorView的创建过程对于理解View的工作原理大有裨益。以一个简单例子来引入：12345678public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main_activity_layout); &#125;&#125; 再来追踪下Activity的setContentView()方法：12345678public class Activity extends ContextThemeWrapper &#123; ... public void setContentView(int layoutResID) &#123; getWindow().setContentView(layoutResID); // 调用PhoneWindow的setContentView来创建DecorView对象 initWindowDecorActionBar(); &#125; &#125; 接下来进入到PhoneWindow中看看DecorView是如何被创建的：1234567891011public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; ... public void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); // 这里创建DecorView. &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); // 这里不是很明白为啥要移除所有的view？？ &#125; ... &#125;&#125; 进入到installDecor()中进一步分析：12345678910111213public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; ... private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); // 创建DecorView对象mDecor. ... &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); ... &#125; &#125;&#125; 进入generateDecor()方法中：123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; 方法很简单，就是new一个DecorView对象。但是此时创建的DecorView仅仅是一个空白的FrameLayout，接下来便是通过generateLayout()方法初始化DecorView的结构：1234567protected ViewGroup generateLayout(DecorView decor) &#123; ... View view = mLayoutInflater.inflate(layoutResource, null); decor.addView(view, new ViewGroup.LayoutParams(FILL_PARENT, FILL_PARENT)); ViewGroup contentParent = (ViewGroup) findViewById(ID_ANDROID_CONTENT); ...&#125; 源码中这个方法很长，但其主要作用就是加载android.R.id.content这个布局文件，然后添加到DecorView中，并初始化mContentParent。以上便完成了DecorView结构的初始化工作。 接下来再回到setContentView()方法中：12345678public void setContentView(int layoutResID) &#123; ... if (hasFeature(FEATURE_CONTENT_TRANSITIIONS)) &#123; ... &#125; else &#123; mLayoutInflator.inflate(layoutResID, mContentParent); // 这里最终将我们设置的布局文件通过inflate加入到mContentParent中. &#125;&#125; 以上过程只是完成了DecorView的创建和初始化工作，创建好了之后实际上DecovView仍旧处于INVISIBLE状态，还需要将DecorView添加到屏幕上，这时就需要用到WindowManager。分下Activity的启动过程，首先调用ActivityThread的handleResumeActivity，接着调用Activity.onResume()方法，接着调用Activity.makeVisible()方法：12345678void makeVisible() &#123; if (!mWindowAdded) &#123; WindowManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; 以上过程便DecorView的整个创建以及初始化过程，这种见省略了不少其他的操作。那么，DecorView是如何同ViewRootImpl关联上的呢？ 继续以上的分析：1wm.addView(mDecor, getWindow().getAttributes()); WindowManager的真实实现是WindowManagerImpl，因此实际上调用的也是WindowManagerImpl.addView()方法：123456@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); // 实际上调用的是WindowManagerGlobal.addView()方法 mGlobal.addView(view, params, mDisplay, mParentWindow);&#125; 接下来进入到WindowManagerGlobal.addView()方法中，这个方法比较复杂，这里作节选：123456789101112131415161718public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ... root = new ViewRootImpl(view.getContext(), display); // 创建View和与之对应的ViewRoot对象 view.setLayoutParams(wparams); mViews.add(view); // 保存view到WindowManagerGlobal中 mRoots.add(root); // 保存ViewRoot到WindowManagerGlobal中 mParams.add(wparams); // 保存布局参数到WindowManagerGlobal中 ... &#125; ... root.setView(view, wparams, panelParentView);&#125; 在这个方法中，创建View对应的ViewRoot对象，ViewRoot控制着一个视图的结构，里面包含于WindowManager通信的Binder对象、View所在界面的ContextImpl、DecorView等信息。 接下来进入到ViewRootImpl.setView()方法中：1234567891011public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; ... requestLayout(); // 首次执行layout，这里会触发onAttachToWindow()和创建Surface，需进一步追踪！！ ... &#125; &#125;&#125; 接下来看一下requestLayout()方法：1234567public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 再进入到scheduleTraversals()方法中：12345678910111213141516171819202122232425void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; ... mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); // 这里重点就是mTraversalRunnable ... &#125;&#125;// mTraversalRunnable定义final TraversalRunnable mTraversalRunnable = new TraversalRunnable();final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;void doTraversal() &#123; if (mTraversalScheduled) &#123; ... performTraversals(); // ！！！！！！大BOSS终于来了！！！！！！ ... &#125;&#125; OKAY！！终于要开始进入到View的绘制流程了！ 2 View的绘制View的绘制绘制流程是从performTraversals()方法开始的，经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽和高，layout用来确定View在父容器中的位置，draw负责将View绘制在屏幕上。其大致流程如下图所示： 上图描述了View绘制的大致流程。下面将详细分析每一步的流程： 2.1 理解MeasureSpec理解MeasureSpec对理解View的测量过程是必须的，字面意思就是“测量说明书”，MeasureSpec从始至终一直参与者View的测量过程。 (1) MeasureSpecMeasureSpec是一个32为的int值，高2为代表SpecMode，意思就是测量模式，低30位代表SpecSize，是指在某种测量模式下的规格大小。123456789101112131415161718192021private static final int MODE_SHIFT = 30;private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;private static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;private static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;private static final int AT_MOST = 2 &lt;&lt; MODE_SHFIT;public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125;&#125;public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK);&#125;public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK);&#125; 从上面代码可以看出，MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为方便操作，其提供了打包和解包操作。 SpecMode有三类：UNSPECIFIED父容器不对View作任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。 EXACTLY父容器已经检测出View所需的精确尺寸大小，这个时候View的最终大小就是SpecSize所指定的值，它对应于LayoutParams中的match_parent和具体的数值这两种模式。 AT_MOST父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么值要看不同View的具体实现，它对应于LayoutParams中的wrap_content。 (2) MeasureSpec和LayoutParams的对应关系正常情况下，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽/高。需要注意的是，MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步确定View的宽/高。 DecorView的MeasureSpec创建过程在RootViewImpl中的measureHierarchy方法中：12345678private boolean measureHierarchy(final View host, final WindwoManager.LayoutParams lp, final Resource res, final int desiredWindowWidth, final int desiredWindowHeight) &#123; ... childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ...&#125; 其中，childWidthMeasureSpec/childHeightMeasureSpec分别为屏幕的尺寸，不难看出，对于顶级DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams共同确定。 普通View的MeasureSpec创建过程对普通的View而言，其measure过程由ViewGroup传递而来。先来看看ViewGroup的measureChildWidhMargins()方法：123456789101112131415protected void More ...measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); // 获取子元素的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); // 对子元素进行measure过程 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 上述代码展示了对ViewGroup中的子元素进行measure过程，在调用子元素的measure方法之前，会先通过getChildMeasureSpec()方法获取子元素的MeasureSpec，同时不难发现，子元素MeasureSpec的创建同父容器的MeasureSpec和子元素本身的LayoutParams直接相关，此外还与子元素的margin及padding有关。getChildMeasureSpec()方法则更进一步说明了子元素MeasureSpec计算过程，具体有兴趣的可以自行了解下。 至此，获取MeasureSpec过程也就结束了，这是View绘制的第一步。 2.2 View的measure过程measure过程需分2中情况来讨论：原始的View和ViewGroup。对于原始的View，通过measure方法就完成了自身的测量过程，对于ViewGroup，除了完成自己的测量之外，还要去递归遍历调用所有子元素的measure方法。 (1) View的measure过程承接上文，在View的measure()方法中，会调用onMeasure()方法，来看看onMeasure()方法：1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 可以看出，onMeasure()方法相当简单，setMeasuredDimension()顾名思义，就是设置View的宽/高，如何设置？来看下getDefaultSize()方法：123456789101112131415public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 简单来看，对绝大多数情况（AT_MOST和EXACTLY），getDefaultSize()返回的就是specSize，而这个specSize就是View的测量大小。但要注意，View最终的大小是在layout阶段确定的，但是几乎在所有情况下View的测量大小总是和最终的大小是相等的。UNSPECIFIED较少用到，追踪源码其实也挺简单，这里不作讨论。 (2) ViewGroup的measure过程对于ViewGroup来说，除了完成自己的measure过程之外，还会递归遍历所有的子元素。ViewGroup是一个抽象类，没有重写View的onMeasure()方法，但是提供了measureChildren()的方法：12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++ i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthSpec, heightMeasureSpec); &#125; &#125;&#125; 上述代码中，ViewGroup进行measure时，会对每一个子元素进行measure，再来看看measureChild()方法：12345678protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 如此便最终实现了ViewGroup的测量过程！！但，归根到底，ViewGroup并没有定义测量的具体过程，这主要是因为ViewGroup是一个抽象类，其测量过程中的onMeasure()方法需要各个子类去具体的实现，比如LinearLayout、RelativeLayout等各自定义了自己的onMeasure()方法。由于ViewGroup子类的不同的布局特性，导致它们的测量细节各不相同，因此ViewGroup并没有实现onMeasure()方法，而是交给具体的子类来实现。具体的可以参考LinearLayout的onMeasure()过程，这里不作细述。 (3) 一个问题刚入门Android的时候，特别是在做Dolphin中的一些动画时候，经常要获取某个特定View个宽/高，当时傻啦吧唧的试图在Activity的onCreate()中获取（因为View的宽/高需要比较早知道），可是无论是view.getWidth()还是view.getMeasuredWidth()，返回的都是0！无赖在onResume()中获取，发现偶尔不为0，但大多数时候都为0！！不知道有没有和我一样SHA的。 实际上，在onCreate()、onStart()、onResume()中都无法正确的获取View的宽/高信息，这是因为View的measure过程和Activity的生命周期不是同步执行的！无法保证在Activity的这些方法调用时，View的测量过程已经完成了，那么如果一定要获取View的宽/高信息呢？该如何做？下面提供几种方法： Activity/View#onWindowFoucusChanged()方法中获取onWindowFoucusChanged()方法说明View已经初始化完毕，宽/高信息已经准备好了，在这里获取View的宽/高信息基本是正确的。(1) View.post(runnable)方法123456789101112@Overrideprotected void onCreate() &#123; super.onCreate(); ... view.post(new Runnable() &#123; @Override public void run() &#123; int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); &#125; &#125;);&#125; (1) ViewTreeObserver方法方法使用ViewTreeObserver的回调方法也可以完成View的测量，比如在OnGlobalLayoutListener这个接口中做。123456789ViewTreeObserver observer = view.getViewTreeObserver();observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; ... int width = view.getMeasuredWidth(); int height = view.getMeasuredHeight(); &#125;&#125;); 2.3 View的Layout过程Layout过程的作用是ViewGroup用来确定其子元素的位置，当ViewGroup位置被确定之后，它在onLayout()中会遍历所有子元素并调用其layout()方法，在layout()方法中onLayout()方法被调用，最终确定所有元素的位置。 也就是：layout()方法确定View本身的位置，而onLayout()方法确定所有子元素的位置。 先来看看View的layout()方法中的关键代码：12345678910// 4个参数分别表示4个顶点public void layout(int l, int t, int r, int b) &#123; ... boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ... &#125;&#125; 从上面代码可以看出，layout()方法的大致流程是：首先通过setFrame()方法来设置View的4个顶点位置，进入setFrame()方法不难看出，其实也就是设置mLeft, mRight, mTop, mBottom这四个值，View的4个顶点确定之后，View在父容器中的位置也就确定了；然后，调用onLayout()方法，这个方法的作用是父容器确定其子元素的位置，onLayout()在View中并无具体的实现，同onMeasure()方法类似，其具体实现依赖于具体的布局，因此View和ViewGroup均没有真正实现onLayout()方法，我们以LinearLayout中的onLayout()方法为例：1234567protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutVertical(l, t, r, b); &#125;&#125; 继续看看layoutVertical()实现：1234567891011121314151617181920void layoutVertical(int left, int top, int right, int bottom) &#123; ... int count = getVirtualChildCount(); ... for (int i = 0; i &lt; count; i ++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); ... setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); &#125; &#125;&#125;private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height);&#125; 可以看出，此方法遍历所有子元素并调用setChildFrame()方法来为子元素指定对应的位置，setChildFrame()中调用了View的layout()方法，最终又回到了上面所提到的情况。 回到前文所提到的：绝大多数情况下，View的测量宽/高和最终的宽/高是相等的，在这里也可以得到证明：1234567public final int getWidth() &#123; return mRight - mLeft;&#125;public final int getHeight() &#123; return mBottom - mTop;&#125; 而在setFrame()方法中，12345678protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... // 这里对顶点参数进行赋值 mLeft = left; mTop = top; mRight = right; mBottom = bottom;&#125; 从上面的onLayout()方法中知道，12right = left + measuredWidth;bottom = top + measuredHeight; 因此，View的默认实现中，View的测量宽/高和最终的宽/高是相等的。除了一下情况：1234// 重写View的layout方法public void layout(int l, int t, int r, int b) &#123; super.layout(l, t, r + 100. b + 100);&#125; 这种情况下，View的最终宽/高总是比测量宽/高大100px。另外一种情况是，View需要多次measure测能确定自己的测量宽/高，前几次的测量过程中，其测量出来的宽/高有可能和最终的宽/高不一致，但最终来讲，测量宽/高还是和最终的宽/高相同。 2.4 View的draw过程View的draw()过程比较简单，它的作用是将View绘制在屏幕上，draw()过程分为以下几部：(1) 绘制背景;(2) 绘制自己；(3) 绘制children;(4) 绘制装饰。 来简要看下draw()方法的实现：12345678910111213141516171819202122232425public void draw(Canvas canvas) &#123; ... // Step 1, draw the background, if needed. if (!dirtyOpaque) &#123; drawableBackground(canvas); &#125; // skip stdp 2 &amp; 5 if possible (common case) if (!verticalEdges &amp;&amp; !horizontalEdge) &#123; // step 3, draw the content if (!dirtyOpaque) &#123; onDraw(canvas); &#125; // step 4, draw the children dispatchDraw(canvas); // step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); ... // we're done... return; &#125;&#125; View绘制过程的传递是通过dispatchDraw()完成的，dispatchDraw()会遍历调用所有子元素的draw()方法，如此实现draw事件的层层传递。 3 References[1] Android源码：http://grepcode.com/search/?query=google+android&amp;entity=project，本文所有代码基于Android 5.1.1_r1[2] 《Android开发艺术探索》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊聊RxJava & RxAndroid]]></title>
      <url>https://xdrush.github.io/2016/06/10/%E8%81%8A%E8%81%8ARxJava%20&%20RxAndroid/</url>
      <content type="text"><![CDATA[一、RxJava简介What is Rx?Rx，即Reactive Extensions，是一种编程模型，目标是提供一致的编程接口，有助于更方便的处理异步数据流。响应式编程主要由Observable、Operator和Subscriber组成，一般来讲，响应式编程的信息流如下：1Observable -&gt; Operator1 -&gt; Operator2 -&gt; ... -&gt; Subscriber 也就是Observable是事件的生产者，Subscriber是事件最终的消费者，并且，Subscriber通常是在主线程中执行，只负责对事件进行响应，这就要求其处理的事情越少越简单越好，而对事件的处理尽量交由Observable和Operator。 RxJava是什么东东？1RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences. 本质上来讲，RxJava就是一个封装异步操作的库！ RxJava核心概念RxJava最核心的2个概念就是：Observable(被观察者、事件源)和Observer(一般用Subscriber，观察者)。Observable产生一系列事件(触摸事件，网络请求，文件读写)，并将这些事件发送出去，Observer处理这些事件所产生的结果。 一个Observable可以发出多个事件，直到结束或者出错，每发出一个事件，就会调用它的Subscriber的onNext()方法，然后再调用onComplete()或者onError()方法作为结束。一个Observable如果没有任何Subscriber，则不会发出任何事件(可简单理解为一段不会执行的代码)，也就是Observable和Subscriber必须成对使用。一个Observable可以同时被多个Subscriber订阅。 举一个最简单的例子来理解Observable和Subscriber，Android中通常这么用： 123view.setOnClickListener(new View.OnClickListener() &#123; // ...&#125;); 这里我们可以简单的理解view就是Observable，OnClickListener就是Subscriber，view和OlClickListener通过setOnClickListener()方法进行绑定，如下图所示： RxJava基本使用步骤举一个简单的例子来示例RxJava基本使用步骤：向屏幕发送一个字符串，并显示出来： 创建Observable123456789101112// String为输入Observable&lt;String&gt; observable = Observable.create(new OnSubscribee&lt;String&gt;() &#123; @Override public void call(Subscribe&lt;? super String&gt; subscriber) &#123; // 产生事件 // TODO: ...... // 事件完成的结果回调 subscriber.onNext("Hello World."); subscripber.onCompleted(); &#125;) 这里定义的Observable仅仅发出了一个”Hello World”字符串，然后就结束了。 创建Subscriber1234567891011121314151617Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt; &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onNext(String string) &#123; System.out.println(string); &#125;&#125; 创建一个Subscriber来处理Observable发出的字符串这个事件，其中onNext()，onCompleted()，onError()是回调方法供Observable调用。 Observable和Subscriber的绑定1Subscription subscription = observable.subscribe(subscriber); 最后将创建的observable和subscriber绑定，subscribe()会返回一个Subscription对象（后文会说明这个对象的作用）。以上便是RxJava使用的“三步走”过程，简单明了。 为什么要用RxJava？上面给出的打印字符串的例子，如果不用RxJava可能一两行就能搞定，那为什么还要如此大费周章的使用RxJava呢？的确，大多数场景下，RxJava是画蛇添足，但别忘了开头所说，RxJava是为异步而生！ 也许Handler，new Thread，AsyncTask…等等已经在脑子里根深蒂固了，不错，这些已经让异步实现更简洁了，但，RxJava会让异步变得更！简！！单！！！并且，随着程序逻辑变得越来越复杂，RxJava依然能够保持代码的简洁性和可读性。注意，这里所说的简单，并不是说代码量会更少，而是指逻辑、结构会更加简单明了。 同样，举一个简单例子：给定一个图片url，设置ImageView【注：这里不考虑Picasso、Fresco等图片库】， 先来看看new Thread()是怎么做123456789101112new Thread(new Runnable() &#123; @Override public void run() &#123; mBitmap = downloadBitmap(url); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;); &#125;&#125;).start(); AsyncTask实现的代码量不会比这更少。 再来看看RxJava是怎么实现的123456789101112131415Observable.just(url) .map(new Func1&lt;String, Bitmap&gt;) &#123; @Override public Bitmap call(String url) &#123; return downloadBitmap(url); &#125; &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;); 暂且不要管上面每行代码是什么意思，看完下文之后自然会明白。上例也许并不恰当，粗看RxJava行数更多，的确，但RxJava以这种链式结构来实现异步，不至于将将代码搞得到处都是。试想，在此基础上作一点扩展，给定10个url来设置一组ImageView呢？来看看RxJava怎么做：1234567891011121314151617String[] iconUrls = new String[]&#123;...&#125;;// ...Observable.from(iconUrls) .map(new Func1&lt;String, Bitmap&gt;) &#123; @Override public Bitmap call(String url) &#123; return downloadBitmap(url); &#125; &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; mImageView[i].setImageBitmap(mBitmap); &#125; &#125;); 对的，就是这么简单，只需改动一两个地方，就可以很完美的应对扩展。这也就是上面所说的，异步操作越复杂，越能体现出RxJava的优势！ 代码简化前面举了打印字符的例子，那个例子中代码过于复杂，我们关注的其实也就是一个回调方法而已，那么，能将这些代码精简些吗？实际上，RxJava内置了很多便捷的函数方便我们来简化代码。下面列出一些常用的简化版方法： Observable简化Single Single是Observable的一个精简版，其功能基本与Observable一样；Observable在某些场景下过于重量级，需要关注其回调方法的onNext()/onComplete()/onError()，但实际上大部分场合只需关注onNext()即可，Single正是这么干的。1234567891011Single.just(T t) .subscribe(new SingleSubscriber&lt;T&gt; &#123; @Override public void onSuccess(T t) &#123; // ... &#125; @Override void onError(Throwable error) &#123; &#125; &#125;); Observable.just(T…)Observable.just()用于创建只发出一个事件就结束的Observable对象：1Observable&lt;String&gt; observable = Observable.just("Hello World"); 如果传入的是一个数据，则将传入的参数依次发送出去。12345Observable observable = Observable.just("hello", "world");// 将会依次调用：// onNext("hello");// onNext("world");// onComplete(); Observable.from(T[])将传入的数组或者Iterator拆分成具体对象，然后依次发送出去。12String[] strings = &#123;"hello", "world"&#125;;Observable observable = Observable.from(strings); 本质上同上面的just()差不多，归根到底和create()是等价的。 Subscribe的简化Subscribe有3个方法，其实大部分时候我们只需要关心onNext()方法而不用在意onComplete()和onError()(上面的例子中不难看出这两个方法占用了不少代码体积)，这时候我们可以使用Action类(Action类无返回值)，RxJava提供了多个参数的Action类，Action1, Action2, Action3, Action4,…,分别表示能处理多少个结果。123456Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; // TODO: do something... &#125;&#125; Observable.subscribe()方法有个重载的版本，接受3个Action1类型的参数，分别对应其onNext()，onCompleted()，OnError()方法：1Observable.subscribe(onNextAction, onErrorAction, onCompleteAction); 如果不关心onError和onCompleted，则只需一个参数即可：1Observable.subscribe(onNextAction); 鉴于此，上例中的代码最终可以简化为：1234567Observable.just("Hello World") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; // TODO: do something... &#125; &#125;); Function简化RxJava中提供了类似上述Action类的简化，同时也提供了包装多个参数并且有返回值的类Func，123public interface Func1&lt;T, R&gt; extends Function &#123; R call(T t);&#125; 以上便是Func1的源码，T为输入参数，R为返回值；同理，Func2接收两个输入一个返回，以此类推。Func在中间变换时非常重要。 二、RxJava操作符Why Operator？对Rx来说，Observable和Subscriber仅仅是个开始，它们本身不过是标准观察者模式的一些轻量级扩展，目的是为了更好的处理事件序列。但Rx真正强大的地方在于它的操作符！ 操作符是为了解决对Observable对象的变换问题，其目的在于对Observable发出的事件在最终的Subscriber得到事件结果之前对Observable发出的事件进行修改。变换不仅能处理单个事件，也能同时处理整个序列中的事件，将这些事件转换成不同的事件。 为什么需要操作符？根据响应式函数编程的概念，Subscriber更应该做的事情是“响应”，响应Observable发出的事件，仅此而已！Observable做的事情仅仅是产生事件，事件产生了就再也不关我事！那么问题来了，如果在事件处理完成之前，想对事件做些特别的处理呢？(这种需求大多数场景下应该都会有的吧)。RxJava中的操作符正是为此而产生的！RxJava的强大和精髓就在于其提供了丰富的操作符。并且，Rx操作符拥有简明的异步操作方式，避免了异步系统中的嵌套回调的回调陷阱问题。下面着重介绍几个常用的操作符： map操作符map操作符对事件对象直接变化，是RxJava中最常用的操作符。回到前面根据url设置ImageView的例子：123456789101112131415Observable.just(url) .map(new Func1&lt;String, Bitmap&gt;) &#123; @Override public Bitmap call(String url) &#123; return downloadBitmap(url); &#125; &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;); 上例中，map()操作符将String对象转换成了一个Bitmap对象后返回，经过map()操作符后，事件的类型也就由String转换为了Bitmap类型。map()是RxJava中最常见的变换，但RxJava提供的变换远不止于此，RxJava还可以对整个事件队列进行变换。 flatMap()操作符flatMap()操作符比较难理解，为了更好的说明flatMap()原理及如何使用好它，先来看一个简单的例子：打印一组学生中每个学生的所有课程。123456789101112131415161718Student[] students = &#123;...&#125;;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; System.out.println(course.getName()); &#125; // ... 忽略onComplete()和onError()&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); 从上面的代码中看，flatMap()和map()有一个相同点：把传入的参数经过转换之后返回一个对象，但map()返回的是普通类型的对象，而flatMap()返回的则是Observable对象，并将这个Observable对象激活，藉由这个Observable对象再将一系列事件发送出去。对于分组网络请求使用flatMap()最好不过了。 subscribeOn操作符用于指定订阅事件所在的线程，也就是异步任务执行的线程，下文详细讲解。 observeOn操作符指定回调所在的线程，常见的就是主线程，下文详细讲解。 RxJava还提供了很多其他的操作符，有兴趣可以查阅相关文档。 三、RxJava中的线程调度既然RxJava处理的是异步事件，那么涉及到线程的调度问题是必然的。RxJava强大的另外一点就是其提供了非常非常非常简便的线程操作！ 默认情况下，如果不指定Observable和Subscriber所在的线程，则所有操作默认与subscribe()所在的线程保持一致，即：在哪个线程中调用subscribe()，就在那个线程中生产事件，同时也就意味着在哪个线程中消费事件。如果需要控制操作所在的线程，这时Scheduler就派上了用场。 RxJava中的几个SchedulerRxJava本身已经内置了几个常用的Scheduler，绝大多数场景下，这些Scheduler已经够用了，这些Scheduler主要有： Scheduler.immediate() 不指定线程，直接在当前线程中执行，这也是默认的Scheduler。 Scheduler.newThread() 开启新的线程，并且在新线程中执行相关操作。 Scheduler.io() I/O操作相关的Scheduler，当有涉及到文件读写、数据库操作、网络操作等时，强烈建议制定这些操作在IO线程中执行，io()线程内部实现是一个无数量上限的线程池，这时不需要开启新线程，直接重用空闲的线程，因此io()比newThread()具有更高的效率。 Scheduler.computation() 计算所使用的线程，主要用于执行CPU密集型的计算操作，比如图形计算等。这个Scheduler拥有固定的线程池，大小为CPU核数。 Scheduler.from(Executor) 使用指定的Executor来作为Scheduler，Executor本质上也是使用了线程池机制，其效率由于new Thread。 Scheduler.trampoline() 在当前线程中的工作放入到队列中排队，并以此执行队列中的事件。 Scheduler.test() 用于测试，支持单元测试的高级事件。 AndroidSchedulers.mainThread() 针对Android引入的一个特殊Scheduler，即Android主线程。 RxJava中Scheduler的使用没什么好说的，结合上面所说的observeOn()和subscribeOn操作符，直接上例子：123456789Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定subscribe()发生在IO线程中 .observeOn(AndroidSchedulers.mainThread()) // 指定Subscribe的回调在主线程中进行 .subscribe(new Action1&lt;Integer&gt; &#123; @Override public void call(Integer number) &#123; Log.d(TAG, String.valueOf(number)); &#125; &#125;); 上例中，subscribeOn(Schedulers.io())指定事件的产生实在IO线程中发生，observeOn(Schedulers.mainThread())则指定回调发生在主线中，这种方式对MVP模型非常适用。事实上，RxJava可以指定中间任意一个Operator所在的线程，线程之间的切换非常非常方便！ Scheduler原理不难发现，RxJava变换的本质都是对事件序列进行处理然后再发送出去，再来看看几个典型的变换源码：123456789// map()实现public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) &#123; return lift(new OperatorMap&lt;T, R&gt;(func));&#125;// isEmpty()实现public final Observable&lt;Boolean&gt; isEmpty() &#123; return lift((OperatorAny&lt;T&gt;) HolderAnyForEmpty.INSTANCE);&#125; 进一步阅读源码我们不难发现，基本上所有的变换都是基于lift(Operator)实现的。 可能存在的内存泄漏问题每个Observable和Subscriber绑定时就会生成一个Subscription对象，一个Subscription代表Observable和Subscriber之间的连接。当在多线程场景下，有时Activity的onDestroy()执行之后线程才结束（有可能该线程永远都不会结束），那么这是就有可能出现内存泄漏或者其他异常信息，这一点值得引起注意。12345678910111213141516171819202122232425// subscribe源码摘录public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) &#123; if (onNext == null) &#123; throw new IllegalArgumentException("onNext can not be null"); &#125; return subscribe(new Subscriber&lt;T&gt;() &#123; @Override public final void onCompleted() &#123; // do nothing &#125; @Override public final void onError(Throwable e) &#123; throw new OnErrorNotImplementedException(e); &#125; @Override public final void onNext(T args) &#123; onNext.call(args); &#125; &#125;); &#125; Subscription正是避免这种问题的关键，通过调用unsubscribe()方法，通知Observable其所发送的事件不会再被Subscriber接收，Observble也就不会继续发送事件，这就避免了上述问题。123456789@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (null != mSubscription &amp;&amp; !mSubscription.isUnsubscribed()) &#123; // 解除Observable和Subscriber之间的绑定 mSubscription.unsubscribe(); &#125;&#125; 需要注意的是，如果有多组Observable和Subscriber，则每组都需做这个操作，RxJava提供了CompositeSubscription这个类用来集合多组订阅，销毁Activity时，清除CompositeSubscription即可。12345678private final CompositeSubscription mCompositeSubscription = new CompositeSubscription();// ...mCompositeSubscription.add(subscription);@Overrideprotected void onDestroy() &#123; mCompositeSubscription.clear();&#125; 四、RxAndroidRxAndroid是RxJava针对Android的扩展，其目的主要是简化异步数据处理，RxJava的引入为在Android中灵活的使用函数式响应编程提供便利，并且Android的线程机制也使得RxJava能够完美的应用在Android开发中。 除了上面那个根据url设置ImageView这个例子之外（如其说是个例子，倒不如说提供的是一种在Android中处理异步任务的思想），RxJava还为Android提供了几个方便的API。 RxAndroid相关APIHandlerScheduler除了上面所讲的AndroidSchedulers之外，RxJava还提供了HandlerScheduler，一个用来指定Handler的Scheduler。1234private Handler mHandler = new Handler(getMainLooper());// ...subscribeOn(HandlerScheduler.from(mHandler)) // 指定发出事件所在的子线程// ... 这个api方便定制事件所在的子线程。 与Retrofit相结合对Retrofie，目前我们用到最多的还是Callback接口，事实上Retrofit本身其实已经提供了Observable形式的接口，举一个从服务器拉取网站列表的例子：先来看Callback形式：1234567891011@Get("/list_url")public void getWebsiteList(@QueryMap Map&lt;String, String&gt;, Callback&lt;WebsiteStruct&gt; callback);// ...getWebsiteList(queryMap, new Callback&lt;WebsiteStruct&gt; &#123; @Override public void onResponse(...) &#123; // ... &#125; // ... onFailure()&#125;); 再来看RxJava形式：12345678910111213@GET("/list_url")public Observable&lt;WebsiteStruct&gt; getWebsiteList(@Query Map&lt;String, String&gt;);// ...getWebsiteList(queryMap) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;WebsiteStruce&gt;() &#123; @Override public void onNext(WebsiteStruce websiteStruce) &#123; // ... &#125; // ... &#125;); 对比发现，其实Callback形式和RxJava形式差不多。但，如果改动一下需求：获取的是一些视频文件的url，要求将这些视频下载下来保存到本地呢？可能你已经凌乱了，这用Retrofit怎么搞啊？嵌套Callback可能是条路，你不妨试试看！反正我是已经凌乱了！但是，我知道，RxJava可以很容易的写出来：1234567891011121314151617181920212223getWebsiteList(queryMap) .flatMap(new Func1&lt;WebsiteStruct, Observable&lt;String&gt; &gt; &#123; @Override public Observable&lt;String&gt; call(WebsiteStruct websiteStruct) &#123; return Observable.from(websietStruct.getData()); &#125; &#125;) .map(new Func1&lt;String, String&gt; &#123; @Override public String call(String url) &#123; File file = downloadFile(url); saveFileToLocal(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;String&gt; &#123; // ... @Override public void onNext(String string) &#123; Toast.makeText(...string...); &#125; &#125;) See？奏是如此简单！ 五、总结So，上面讲了这么多，希望能够带你入门RxJava和RxAndroid，更多用法不妨去看下源码；如果你已入门，那么，滚蛋吧AsyncTask，忘掉该死new Thread，Callback？再见！！ 其他的用法目前暂未知，后续学到了或者用到了，再补充！ 参考[1] https://github.com/ReactiveX/RxJava[2] https://github.com/ReactiveX/rxjava/wiki[3] ReactiveX/RxJava文档中文版[4] 给Android开发者的RxJava详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Retrofit下载文件]]></title>
      <url>https://xdrush.github.io/2016/05/12/%E4%BD%BF%E7%94%A8Retrofit%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      <content type="text"><![CDATA[说明这里不会对Retrofit进行介绍，欲了解Retrofit的请自行google之。这里只关注如何用Retrofit从服务器下载文件。 Retrofit下载普通文件这里普通文件是指比较小的文件，比如图片、文本等。如果你厌倦了HttpRequest下载文件的方式，相信你看了下文一定会喜欢上Retrofit的。这里我以Android中下载网络图片来设置ImageView为例： 定义Retrofit接口123456789101112131415private final static String mBaseUrl = "http://opsen-static.dolphin-browser.com"; private final static String mFileUrl = "/resources/icon/provision_services/1443166704.png";interface DownloadServiceApi &#123; @GET(mFileUrl) Call&lt;ResponseBody&gt; getSmallSizeFile();&#125;private DownloadServiceApi getDownloadServiceApi() &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(mBaseUrl) .build(); return retrofit.create(DownloadServiceApi.class);&#125; 异步下载图片并设置ImageView1234567891011121314151617181920212223242526272829303132333435363738// 网络操作另开线程来做.new Thread(new Runnable() &#123; @Override public void run() &#123; downloadFile(); &#125;&#125;).start();private void downloadSmallFile() &#123; DownloadServiceApi downloadServiceApi = getDownloadServiceApi(); final Call&lt;ResponseBody&gt; call = downloadServiceApi.getSmallSizeFile(); try &#123; // 同步下载文件 Response&lt;ResponseBody&gt; response = call.execute(); if (response.isSuccessful()) &#123; ResponseBody responseBody = response.body(); byte date[] = responseBody.bytes(); final Bitmap bitmap = BitmpaFactory.decodeByteArray(data, 0, date.length); // 设置ImageView，注意要在UI线程中做. runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mImageView.setImageBitmap(bitmap); &#125; &#125;); &#125; &#125; catch (Exception e) &#123; Log.e(TAG, e.toString()); &#125;&#125;new Thread(new Runnable() &#123; @Override public void run() &#123; downloadSmallFile(); &#125; &#125;).start(); 有一点需要注意，那就是必须以ResponseBody作为返回类型，Retrofit会试图解析并转换它，所以不能使用任何其他返回类型，否则下载的文件毫无意义。 文件下载下来了，要保存在本地也就是很简单的事了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private boolean writeResponseBodyToDisk(ResponseBody responseBody) &#123; try &#123; File saveFile = new File(getExternalFilesDir(null) + File.separator + "MyFile.apk"); InputStream inputStream = null; OutputStream outputStream = null; try &#123; byte[] fileReader = new byte[2000]; inputStream = responseBody.byteStream(); outputStream = new FileOutputStream(saveFile); while (true) &#123; int read = inputStream.read(fileReader); if (-1 == read) &#123; break; &#125; outputStream.write(fileReader, 0, read); &#125; outputStream.flush(); // 提示下载成功. runOnUiThread(new Runnable() &#123; @Override public void run() &#123; showTips("Save to local storage finished!"); &#125; &#125;); return true; &#125; catch (Exception e) &#123; return false; &#125; finally &#123; if (null != inputStream) &#123; inputStream.close(); &#125; if (null != outputStream) &#123; outputStream.close(); &#125; &#125; &#125; catch (Exception e) &#123; Logger.e(e.toString()); &#125; return false; &#125; private void showTips(String tips) &#123; Toast.makeText(MainActivity.this, tips, Toast.LENGTH_SHOW).show(); &#125; Retrofit下载大文件默认情况下，Retrofit在处理结果之前会将这个ResponseBody读进内存，这在普通文件的Response上表现还好，但如果是一个视频等大文件，就极有可能导致OutOfMemory。 好在Retrofit为了避免这个问题，引入了Streaming注解！它意味着立即传递字节码而不是一下子传递整个文件然后缓存在内存中。来看下面的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface DownloadServiceApi &#123; @GET(mFileUrl) Call&lt;ResponseBody&gt; getSmallSizeFile(); @Streaming @GET Call&lt;ResponseBody&gt; getBigSizeFile(@Url String fileUrl);&#125;private void downloadBigFile() &#123; String fileUrl = "........"; DownloadServiceApi downloadServiceApi = getDownloadServiceApi(); final Call&lt;ResponseBody&gt; call = downloadFileApi.getBigSizeFile(fileUrl); // 异步下载文件. call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, final Response&lt;ResponseBody&gt; response) &#123; if (response.isSuccessful()) &#123; showTips("download Successful and start writing file to local storage."); new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... voids) &#123; boolean writeResult = writeResponseBodyToDisk(response.body()); return null; &#125; &#125;.execute(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; showTips("download failed!"); &#125; &#125;);&#125; new Thread(new Runnable() &#123; @Override public void run() &#123; downloadBigFile(); &#125; &#125;).start(); 这里也有一点需要特别注意：onResponse()、onFailure()方法都是在主线程中调用的，因此最好使用AsyncTask()来处理保存文件到本地的操作，不然会阻塞UI线程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ActivityThread & Instrumentation在MultiDex实现中的应用]]></title>
      <url>https://xdrush.github.io/2016/04/27/ActivityThread%20&%20Instrumentation%E5%9C%A8MultiDex%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="text"><![CDATA[背景说明这篇文章可以看作是对MultiDex实践的一篇补充，更进一步的背景是对美团MultiDex实现的一些具体细节的一种实现方式。 同美团团队一样，在实现MultiDex时，同样遇到一个问题，那就是：部分在classes2.dex中的二级界面，首次启动时，如果classes2.dex尚未加载完，而这时用户操作了该二级界面，Crash！！是必然的！美团的那篇文章也讨论了这个问题，解决方法就是在操作二级界面Activity时，首先判断classes2.dex是否加载完毕，如果加载完毕，则直接启动该Activity，如果尚未加载完毕，则引入一个WaitActivity，在WaitActivity中阻塞等待classes2.dex加载完成，等dex2加载完毕之后再启动该二级界面Activity。 这么做肯定是没有问题的，但有一点就是，如果二级界面太多，每个调用的地方都去判断dex2是否加载完未免太麻烦，好在Framework告诉了我们答案！我们知道Activity是由ActivityThread通过Instrumentation来启动的，再进一步跟进去，我们发现ActivityThread中有一个mInstrumentation对象，该对象即是Instrumentation，进一步查看Instrumentation源码，发现其与Activity启动相关的方法有以下几个：execStartActivity, newActivity等等，于是，我们就可以在这里面做些手脚！怎么做？修改Instrumentation或者ActivityThread也未免显得太过幼稚了！那么How？方法其实很简单：(1)自定义MyInstrumentation继承自Instrumentation；(2)通过放射方式在应用刚启动时以MyInstrumentation替换掉ActivityThread中的mInstrumentation，替换的时机最好实在Application.attachBaseContext()中。 自定义Instrumentation首先自定义MyInstrumentation继承自Instrumentation，在newActivity中作判断该Activity是否加载完，代码如下：123456789101112public class MyInstrumentatin extends Instrumentation &#123; @Override public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Log.d(TAG, className); if (isActivityInDex2() &amp;&amp; !isDex2Installed) &#123; className = "com.myapp.WaitActivity"; &#125; return (Activity)cl.loadClass(className).newInstance(); &#125;&#125; 有了这关键的一步，WaitActivity的实现细节这里就不作多述，有兴趣的可以私我！ 注册MyInstrumentation实现了MyInstrumentation，剩下的就是以MyInstrumentation替换掉系统的Instrumentation，实现如下：123456789101112131415161718192021222324252627public class MyApplication extends Application &#123; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); registerMyInstrumentation(); &#125;&#125;/*** 反射方式替换掉系统Instrumentation.*/public static void registerMyInstrumentation() &#123; try &#123; Class activityThreadClass = Class.forName("android.app.ActivityThread"); Field instrumentationField = activityThreadClass.getDeclaredField("mInstrumentation"); instrumentationField.setAccessible(true); MyInstrumentation myInstrumentation = new MyInstrumentation(); Method getActivityThread = activityThreadClass.getDeclaredMethod("currentActivityThread"); Object object = getActivityThread.invoke(null); instrumentationField.set(object, myInstrumentation); &#125; catch (Exception e) &#123; Log.e(TAG, e.toString()); &#125;&#125; 至此，比较完备的MultiDex实现方式算是告一段落了，整个过程，给我最大的感受就是：Read the Fucking Source Code是多么重要！RTFSC过程中，不仅能学到别人代码的组织形式，更重要的是能够从根本上为解决某些问题提供思路！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MultiDex实践]]></title>
      <url>https://xdrush.github.io/2016/04/20/MultiDex%E5%AE%9E%E8%B7%B5/</url>
      <content type="text"><![CDATA[Why MultiDex?Android应用65535方法数的限制一直为广大开发者所诟病，在应用功能越来越丰富、各种开源库越来越多的今天，65k方法数瓶颈俨然已是一大绊脚石。至于怎么解决这个问题，先来看看google官方给出的方案： 插件化 将应用的非核心功能做成单独的App，实现该App和插件App相关的接口即可，实现以及体验如何，大家不妨来体验下Dolphin浏览器（这里做个小广告）。 MultiDex 多dex实现，对大多数App，解压其apk，一般只有一个classes.dex文件，采用MultiDex的App解压可以看到有classes.dex,classes2.dex,…classes(N).dex，这样每个dex都可以最大承载65535个方法，很大限度的解决了单dex方法数限制。 下文将详细介绍MultiDex如何实现。 MultiDex初步实现google官方MultiDex实现Google官方MultiDex实现用起来比较简单： gradle中添加MultiDex支持 1multiDexEnable true 加载classes2.dex AndroidManifest.xml的application中添加MultiDexApplication，或者如果已经重载Application，则在onAttachBaseContext()中执行MultiDex.install()即可加载dex2。 官方方案简单易用，但遗留的问题也不少，具体注意事项可以google官文有很详细的阐述，这里不再讨论，但使用时有一点需要注意，那就是只有在应用方法数接近65k(注意是接近65k而非确切的65k，之所以提到是因为这个坑导致了线上一个版本hotfix)时才会打包为2个dex文件，具体超过多少个方法数会打包多个dex可以通过设置dx的’–set-max-idx-number’来决定。 MultiDex初步应用最初版本，App还只是超过65535大概上百个方法，就按google官方方案对App进行多dex支持，启动发现无任何异常(包括启动速度、启动ANR、Crash等)，classes2.dex也只有带该二三十KB大小，暗自窃喜了一小阵子！好景不长，随着下一个版本一个新的SDK的引入，导致classes2.dex文件达到了200KB，测试发现不少机型启动ANR或者crash，或者启动时间过长，再次去看了google提出的MultiDex存在的问题，嗯，发现基本都是描述的那些问题！ 接下来在上个版本的基础上稍作改动，先来看下App启动流程：12Application.attachBaseContext()-&gt;Application.onCreate() -&gt; MainActivity.onCreate -&gt;MainActivity.onStart() -&gt; MainActivity.onResume() 不难发现，Application.attachBaseContext是我们能控制的最早执行的代码，在这个方法里面执行MultiDex.install()无疑是最佳时机。还有一点我们需要了解，Dalvik虚拟机首次启动对classes.dex执行DEXOPT操作非常耗时，而执行MultiDex.install()必然会再次对classes2.dex执行DEXOPT等操作，所有这些操作必须在5s内完成，否则ANR给你看！非首次启动则直接从cache中读取已经执行过dexopt的文件ODEX，这个过程对启动并无太大影响（测试中发现首次启动dex2加载需要1~2s，非首次启动几十ms左右），这也大概就是为什么classes2.dex不能太大的一个原因。基于此，对attachBaseContext稍作改动： 123456789101112131415161718192021@Overrideprotected void attachBaseContext(final Context base) &#123; super.attachBaseContext(base); // TODO: your init code here. initOperationBeforeDex2Installed(); boolean isAppFirstLaunch = FirstLaunchManager.getInstance().firstLaunch(); if (isAppFirstLaunch) &#123; // 首次启动 new Thread(new Runnable() &#123; @Override public void run() &#123; MultiDex.install(base); // TODO: your init code here, some init operation of which some classes were divided into dex2. initOperationAfterDex2Installed(); &#125; &#125;).start(); &#125; else &#123; // 非首次启动 MultiDex.install(base); // TODO: your init code here, some init operation of which some classes were divided into dex2. initOperationAfterDex2Installed(); &#125;&#125; 以上逻辑便是改动之后的初步实现，首次启动开启一个线程来加载dex2，防止阻塞UI线程，非首次启动则同步执行；initOperationAfterDex2Installed()方法是根据Classes2.dex中结果，将涉及到的相关初始化工作移到dex2加载完之后执行，避免启动问题。当然这么做还不够，现在很多App在首次启动时引入闪屏页，我们的App首次启动也有一个FirstLaunchActivity来实现闪屏，闪屏结束之后就进入MainActivity，在进入MainActivity之前，运行一段阻塞代码来判断dex2是否加载完毕，如果dex加载完成，则立即进入MainActivity，如果尚未加载完毕，则阻塞等待dex2加载完毕，这么做主要还是为了避免启动过程中的ANR/Crash。 MultiDex引起的ANR/CrashANR！！Crash！！对，这就是MultiDex引起的坑！通过以上方法初步实现了MultiDex，但时不时QA就来找我：“这个机型ANR了”，“这个机型又ANR了”，“这个机型怎么又Crash了”，“这个手机启动不了”，简直令人抓狂！云测试通过率也没之前的高！实际上所有这些都是同一个问题导致的：dex2没加载完成之前，程序调用了dex2中的类或者方法！adb logcat看下，基本也就是4类问题引起的：1234(1) NoClassDefFoundError(2) Could not find class(3) Could not find method(4) NDK Error 这里需重点讨论下NDK error，这种问题是在有JNI调用的时候才会发生，并且出现的比较诡异，我也是在云测试的时候才注意到这个问题的严重性，通过观察启动的log，查找SIGSEGV，died等关键字，发现在这些关键字附近会有诸如“unable to find **”，其实这里就是没有找到的类引起的NDK error的关键所在，解决方法当然就是将这些类放到classes.dex中。个人建议在用MultiDex时，多次启动看logcat，重点关注以上3个类型的信息！知道了哪些类引起的错误之后，只需将这些类强制分到classes.dex中即可。那么如何实现呢？这里还得简要了解下MultiDex编译过程以及涉及到分包的几个重要task。 MultiDex编译过程gradle task简介限于篇幅这里不对gradle、groovy作介绍，想了解的google上有不少好资料，这里只简要介绍gradle中的task以及MultiDex编译过程中重要的几个task，这是最终MultiDex实现的关键。 task，顾名思义就是任务的意思，是执行Project构建的基本单位，一个工程所有的构建最终是由一个个task来完成，这里我们来分析一个简单的build日志（PS：当我们输入gradle build按下Enter之后，屏幕上biu的一下多了不少日志信息，实际上这些日志信息就是一个个task的输出信息，阅读build日志对我们理解整个工程的构建大有裨益），以下面一段build日志为例：123456MyProject:generateReleaseSourcesMyProject:processReleaseJavaResMyProject:compileReleaseNdk UP-TO-DATEMyProject:compileReleaseSourcesMyProject:collectReleaseMultiDexComponentsMyProject:proguardRelease 日志中，generateReleaseSources、processReleaseJavaRes…、proguardRelease都是构建过程中依次执行的task任务，这些task分别完成不同的功能，欲知更多task信息，RTFSC无疑是不二选择，gradle相关task源码请移步这里。MultiDex编译过程最重要的task主要有3个： collect{Release/Debug}MultiDexComponents这个task扫描AndroidManifest.xml文件中的application、activity、receiver、provider、service等相关类，这将这些类信息写入到manifest_keep.txt文件中，该文件位于build/intermediates/multi-dex/{release/debug}目录下。 shrink{Release/Debug}MultiDexComponents这个task会根据proguard规则以及manifest_keep.txt文件来进一步优化manifest_keep.txt，将其中没有用到的类删除，最终生成componentClasses.jar文件，该文件同样位于build/intermediates/multi-dex/{release/debug}目录下。 create{Release/Debug}MainDexClassList这个task会根据上步中生成的componentClasses.jar文件中的类，递归扫描这些类所有相关的依赖类，最终形成maindexlist.txt文件，该文件也位于build/intermediates/multi-dex/{release/debug}目录下，这个文件中的类最终会打包进classes.dex中。需要注意的是，maindexlist.txt文件并没有完全列出有所的依赖类，如果发现要查找的那个class不在maindexlist中，也无需奇怪。如果一定要确保某个类分到主dex中，将该类的完整路径加入到maindexlist中即可，这里要注意，如果加入的类并不在project中，则gradle构建会忽略这个类，如果加入了多个相同的类，则只取其中一个。这3个task在build日志中都能找到。 MultiDex ANR/Crash解决方法知道了上面的几个task，回到前面的问题：如何将某个类强制打包到classes.dex中？上面的3个task已经给出了答案！对，只需将该类完整路径添加到maindexlist.txt文件中即可！create{Debug/Release}MainDexClassList这个task正是实现这个操作的关键，主要代码如下：12345678910111213141516171819tasks.whenTaskAdded &#123; task -&gt; if (task.name.startsWith("create") &amp;&amp; task.name.endsWith("MainDexClassList") &#123; task.doLast &#123; File tempFile File keepFile if (task.name.contains("Debug")) &#123; tempFile = new File("$project.rootDir/MyProject/keep_in_maindexlist_debug.txt") keepFile = new File("$&#123;project.buildDir&#125;/intermediates/debug/maindexlist.txt") &#125; else if (task.name.contains("Release")) &#123; tempFile = new File("project.rootDir/MyProject/keep_in_maindexlist_release.txt") keepFile = new File("&#123;project.buildDir&#125;/intermediates/release/maindexlist.txt") &#125; tempFile.eachLine("utf-8") &#123; str, linenumber -&gt; keepFile.append(str + "\n") &#125; &#125; &#125;&#125; 这里将需要强制分到classes.dex中的类放在keep_inmaindexlist{debug/release}.txt，这种实现方式基本能够解决眼前问题，但现在看来还是略显too simple too navie！主要问题是不可控性，任何一次对代码的改动都有可能导致不同的分包结果，这就可能隐藏着不同的类导致首次启动失败，大量测试结果事实上也证明了这种方法的不可控性。作为开发，代码的不可控性无疑无法忍受，如何改进这种方法使得MultiDex可控呢？与Dev Lead交流之中间接找到了一种改进的方案，下文细述这个方法。 MultiDex的一种改进实现那么该如何让MultiDex分包可控呢？我的做法是：找出启动过程中所有类及依赖类，强制放入到classes.dex中！这么做要求启动类不能太多(实际上大部分App从启动Application到进入MainActivity也就几个直接类)，同时尽量让主界面和二级界面充分解耦，如果不想对现有代码做太多改动，一种做法是以反射方式调用二级界面中的Activity(因为反射找不到依赖关系)，不过调用时得要先判断classes2.dex是否加载完，以防某些二级界面相关代码在classes2.dex中而引起的crash，这么做虽然对功能实现上并无影响，但可能导致代码可维护性降低。另外还有一点就是，我们可以控制哪些类在classes.dex中，但无法控制哪些类分到classes2.dex中(通过dx打包的方式就另当别论了)，以反射方式调用二级界面activity可以增大二级界面相关类分到dex2中的概率。 寻找启动类如何找出App启动到主界面显示这个过程中的所有类？网上能够找得到的方法比较少，美团有自己的脚本程序找启动依赖类，但人家没开！源！！啦！！！还好google找到了CDA(Class Dependency Analyzer)，通过这个工具，基本都能找到启动过程中所有Activity、Application等相关依赖类，通常会有一定偏差(会将某些系统方法也找出来了)，这时还需结合App的所有类来作进一步优化(获取App所有类只需反编译dex文件形成jar，解压jar包，再用shell相关工具处理即可得到)，取两者的交集基本就能找出所有启动依赖类了。这里有一点需注意：必须以debug版本的App来分析，下文会讲到为什么。 Release版本寻找启动类为什么要将Release版本单独拿出来说呢？对，就是因为混淆！混淆可能会导致每次编译形成的class文件名不同，代码的增加或者减小也会对混淆结果产生影响，这就可能导致每次编译所需的启动类名都不一样，而Debug版本因为不会进行代码混淆，因此启动过程中的类名基本变化不大。那么问题来了，如何确定Release版本启动依赖类呢？build日志！！对，通过编译日志，我们发现，proguard{Release/Debug}这个task在create{Release/Debug}MainDexClassList这个task之前执行，这意味着，在形成maindexlist之前，我们能够确切的知道哪些类进行了混淆以及混淆之后的类名！如何获知？proguard的产物给出了答案：build/outputs/mapping/release/目录下的4个txt文件就是proguard的产物：1234dump.txt:所有class文件的内部结构mapping.txt：源码与混淆之后的类、方法、属性名字之间的一一映射关系seeds.txt：未被混淆的类和属性usage.txt：从Apk中剥离的代码 这里mapping.txt文件正是我们需要的，至于另外的3个文件有兴趣的可以研究下。我们来看下mapping.txt中文本的结构：12345678android.support.ActivityManagerCompat -&gt; android.support.a: 48:52:int getLargeMemoryClass() -&gt; a 62:83:boolean isHighEndGfx(android.content.Context) -&gt; aandroid.support.ClipboardManagerCompat -&gt; android.support.b: 29:32:android.support.ClipboardManagerCompat getInstance(android.content.Context) -&gt; a java.lang.CharSequence getText() -&gt; a void setText(java.lang.CharSequence) -&gt; a boolean hasPrimaryClip() -&gt; b 从上述信息中，我们知道经过代码混淆，android.support.ActivityManagerCompat在release版中最终打包为android.support.a类，并且对其中的方法也进行了混淆。并且注意到，文本中对类混淆的行已”:”结尾，这下问题就有解了，根据startup_keep_list_debug.txt文件中的每一行，在mapping.txt中寻找其是否被混淆，如果被混淆了，则读取经过混淆的类，如果没有被混淆，则直接获取该类，通过这几个步骤，即可形成最终Release版本的启动依赖类，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if (task.name.startsWith("create") &amp;&amp; task.name.endsWith("MainDexClassList")) &#123; task.doLast &#123; println "create MainDexClassList" File debugStartupFile = new File("$project.rootDir/MyProject/startup_keep_list_debug.txt") if (task.name.contains("Debug")) &#123; keepFile = new File("$&#123;project.buildDir&#125;/intermediates/multi-dex/debug/maindexlist.txt") // 情况maindexlist.txt FileWriter fileWriter = new FileWriter(keepFile) fileWriter.write("") fileWriter.close() // 写入启动依赖类到maindexlist.txt中 debugStartupFile.eachLine("utf-8") &#123; str, linenumber -&gt; keepFile.append(str + "\n") &#125; &#125; else if (task.name.contains("Release") &#123; File startupFile = new File("$&#123;project.buildDir&#125;/intermediates/multi-dex/release/maindexlist.txt") FileWriter fileWriter = new FileWriter(startupFile) fileWriter.write("") fileWriter.close() File mappingFile = new File("$&#123;project.buildDir&#125;/outputs/mapping/release/mapping.txt") debugStartupFile.eachLine("utf-8") &#123; str, linenumber -&gt; boolean hasProguarded = false mappingFile.eachLine("utf-8") &#123; mapStr, linenumber1 -&gt; String string = mapStr.substring(0, mapStr.indexOf("-&gt;") - 1) string = string.replace('.', '/') string += ".class" if (string.equals(str)) &#123; String strTmp = mapStr.substring(str.length() - 2) strTmp = strTmp.replace('.', '/') strTmp = strTmp.replace(':', '.class') startupFile.append(strTmp + "\n") hasProguarded = true return &#125; &#125; &#125; if (!hasProguarded) &#123; startupFile.append(str + "\n") &#125; &#125; &#125;&#125; 至此，寻找启动类工作基本完成，但不难发现一个问题，那就是build release版本是将会更加耗时，从上面gradle脚本中不难发现，涉及到2层循环，并且mapping.txt文件通常有上万行，这也是这种方法最大的缺陷之一。构建得到APK之后，点击icon，貌似一切正常work！但，但，但，重要的事说三遍，至此并非所有事情都做完了，仍然可能会遗留一些问题！通过以上方法找到的启动依赖类并非100%正确，几千上万个类中遗漏几个毕竟不是小概率事件，解决方法还得多次启动，通过adb logcat获取启动日志，在日志中查找NoClassDefFoundError、Could not find class、Could not find method等warning，有必要的话仍需将这些形成warning的类添加到startup_keep_list_debug.txt文件中，多次启动，直到没有相关的warning，这么做是为了减小未知风险。至此，这种MultiDex实现方法基本也就完成了，后续会寻求其他更好的解决方案，比如动态加载dex方式等等。 MultiDex使用小结以上基本上就是我实现MultiDex的整个过程，中间有多少坑只有实现了才知道！个人认为无必要和绝对把握还是远离它比较好，特别是针对用户量大的App，任何线上ANR/Crash的影响范围可想而知。 提高代码质量应该足以避开MultiDex，毕竟人家微信这么大个App也才只有65428个方法，人家还没超65536呢！ 多次启动(指首次启动)查看启动log是必须的，一来测试MultiDex是否会对首次启动时间产生明显影响，最重要的还是查看启动过程中是否有找不到的类； 通常多次云测也是必须的，毕竟QA能够覆盖到的机型有限，云测也节省了QA工作量。 以上便是个人实现MultiDex的一种方式，不尽完美但却能够解决当下问题，但仍然在寻求最优的解决方法，当你看到这篇文章时，如果你有好的建议或者意见，请不吝赐教！ 相关参考[1] http://developer.android.com/tools/building/multidex.html[2] http://blog.waynell.com/2015/04/19/android-multidex/[3] http://tech.meituan.com/mt-android-auto-split-dex.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[About Me]]></title>
      <url>https://xdrush.github.io/2016/04/16/About_XDRush/</url>
      <content type="text"><![CDATA[Education ExperienceBS.2008/9~2012/6：Huazhong University of Science of TechnologySchool of Automation……………………………………………………MS.2012/9~2015/6: Huazhong University of Science of TechnologyElectronics and Information Engineering Working Experience2015/7~Now： MoboTapAndroid developer SkillsC/C++，Java，Python，Linux，Android，Matlab ContactsEmail: xdrushing@gmail.com or xudong_hust@126.comWeChat: XDRush]]></content>
    </entry>

    
  
  
</search>
